local rs = game:GetService("RunService")
local tweens = game:GetService("TweenService")

script:WaitForChild("Owner")
Pl =  game.Players:WaitForChild(script.Owner.Value)
Player = Pl
repeat
	wait(.1)
until script.Owner.Value ~= nil
C = Pl.Character
if not C then
	repeat
		wait()
	until Pl.Character
end
C = Pl.Character
Hum = C:WaitForChild("Humanoid",3)
if not Hum then
	Hum = Instance.new("Humanoid",C)
end
CFR = CFrame.new

local plr = C

rad = math.rad;
cos = math.cos;
sin = math.sin;
tan = math.tan;
pi = math.pi;
cosh = math.cosh;
sinh = math.sinh;
local LerpFactor, Alpha = .1,.1
sine = 0
sine2 = 25
sine3 = 50
change = 1

-- Animate has now Ceased -- //

-- Limb Setup. --
local char = C







hed = char:WaitForChild("Head")
local Torso = char:WaitForChild("Torso")
local rarm = char:WaitForChild("Right Arm")
local larm = char:WaitForChild("Left Arm")
local lleg = char:WaitForChild("Left Leg")
local rleg = char:WaitForChild("Right Leg")
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
LS=Torso:WaitForChild("Left Shoulder") 
RS=Torso:WaitForChild("Right Shoulder")
LH=Torso:WaitForChild("Left Hip")
RH=Torso:WaitForChild("Right Hip")

euler = CFrame.fromEulerAnglesXYZ
cf = CFrame.new
angles = CFrame.Angles
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=char.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
local root = char:FindFirstChild'HumanoidRootPart'
player=Player 
ch=char
-- 
RS.Name="Right Shoulder"
RS.Part0=ch.Torso 
RS.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RS.C1=cf(0, 0.5, 0) 
RS.Part1=ch["Right Arm"] 
RS.Parent=ch.Torso 
-- 
LS.Name="Left Shoulder"
LS.Part0=ch.Torso 
LS.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LS.C1=cf(0, 0.5, 0) 
LS.Part1=ch["Left Arm"] 
LS.Parent=ch.Torso 
-- CFrame End --

local core,coreweld,penta,cyli,double,dupli,cog
local w1w,w2w,w3w,w4w,w5w,w6w,w7w,w8w,w9w,w10w,w11w,w12w
local wing1,wing2,wing3,wing4,wing5,wing6,wing7,wing8,wing9,wing10,wing11,wing12
local plr = workspace:WaitForChild(script.Owner.Value)
local wingstyle = plr:WaitForChild("LastStar"):WaitForChild("Values"):WaitForChild("WingStyle")
local anim = plr:WaitForChild("LastStar"):WaitForChild("Values"):WaitForChild("Anim")
local fury = plr:WaitForChild("LastStar"):WaitForChild("Values"):WaitForChild("Fury")
local height = 0
coroutine.resume(coroutine.create(function()
	rs.RenderStepped:Connect(function()
		C = workspace:FindFirstChild(script.Owner.Value)
		plr = C

		char = C
		if char ~= nil then
			if char:FindFirstChild("Torso") then
				Torso = char.Torso
			end
			local lar = char:FindFirstChild("Left Arm")
			if lar then
				larm = char["Left Arm"]
				la = char["Left Arm"]
			else
				Instance.new("Part",char).Name = "Left Arm"
			end
			local rar = char:FindFirstChild("Right Arm")
			if rar then
				rarm = char["Right Arm"]
				ra = char["Right Arm"]
			else
				Instance.new("Part",char).Name = "Right Arm"
			end
			if char:FindFirstChild("Left Leg") and char:FindFirstChild("Right Leg") then
				lleg = char["Left Leg"]
				rleg = char["Right Leg"]
				rl = char["Right Leg"]
				ll = char["Left Leg"]
			end
		end
		
		if plr then
			wing1,wing2,wing3,wing4,wing5,wing6,wing7,wing8,wing9,wing10,wing11,wing12 = plr:WaitForChild("Wing1",99999),plr:WaitForChild("Wing2"),plr:WaitForChild("Wing3"),plr:WaitForChild("Wing4"),plr:WaitForChild("Wing5"),plr:WaitForChild("Wing6"),plr:WaitForChild("Wing7"),plr:WaitForChild("Wing8"),plr:WaitForChild("Wing9"),plr:WaitForChild("Wing10"),plr:WaitForChild("Wing11"),plr:WaitForChild("Wing12")
			w1w,w2w,w3w,w4w,w5w,w6w,w7w,w8w,w9w,w10w,w11w,w12w = wing1:WaitForChild("Motor1",99999),wing2:WaitForChild("Motor2"),wing3:WaitForChild("Motor3"),wing4:WaitForChild("Motor4"),wing5:WaitForChild("Motor5"),wing6:WaitForChild("Motor6"),wing7:WaitForChild("Motor7"),wing8:WaitForChild("Motor8"),wing9:WaitForChild("Motor9"),wing10:WaitForChild("Motor10"),wing11:WaitForChild("Motor11"),wing12:WaitForChild("Motor12")
			wingstyle = plr:WaitForChild("LastStar").Values:WaitForChild("WingStyle")
			anim = plr:WaitForChild("LastStar").Values:WaitForChild("Anim")
			fury = plr:WaitForChild("LastStar").Values:WaitForChild("Fury")
			core = plr:WaitForChild("Core")
			if core then
				coreweld,penta,cyli,double,dupli,cog = core:WaitForChild("CoreWeld"),core:WaitForChild("Penta"),core:WaitForChild("Cyli"),core:WaitForChild("Double"),core:WaitForChild("Dupli"),core:WaitForChild("Cog")
			end
		end
	end)
end))

if not wing1 then
	repeat
		wait()
	until wing1
end
if wing1 then
	wing1.Primary.Changed:Connect(function(c)
		if c == "Color" then
			local p = wing1.Primary.Color
			local s = wing1.Secondary.Color
			for i,v in pairs({wing2,wing3,wing4,wing5,wing6}) do
				v.Primary.Color = p
				v.Secondary.Color = s
				v.Spin.Color = p
				v.Primary.PointLight.Color = p
				v.Particle["0"].Main.Color = ColorSequence.new(p)
				v.Particle["0"].Secondary.Color = ColorSequence.new(p)
				v.Particle["0"].Shine.Color = ColorSequence.new(p)
				v.Trail.Color = ColorSequence.new(p)

				v.Primary.Main.Color = ColorSequence.new(p)
				v.Secondary.Main.Color = ColorSequence.new(s)
				v.Particle["0"].Circle.Color = ColorSequence.new(p)
			end
			if wing7.Primary.Transparency == 0 then
				for i,v in pairs({wing7,wing8,wing9,wing10,wing11,wing12}) do
					local p = wing1.Primary.Color
					local s = wing1.Secondary.Color
					v.Primary.Color = p
					v.Secondary.Color = s
					v.Spin.Color = p
					v.Primary.PointLight.Color = p
					v.Particle["0"].Main.Color = ColorSequence.new(p)
					v.Particle["0"].Secondary.Color = ColorSequence.new(p)
					v.Particle["0"].Shine.Color = ColorSequence.new(p)
					v.Trail.Color = ColorSequence.new(p)

					v.Primary.Main.Color = ColorSequence.new(p)
					v.Secondary.Main.Color = ColorSequence.new(s)
					v.Particle["0"].Circle.Color = ColorSequence.new(p)
				end
			end
			for i,v in ipairs({wing1,wing2,wing3,wing4,wing5,wing6,wing7,wing8,wing9,wing10,wing11,wing12}) do
				v.Beam.Color = ColorSequence.new(v.Primary.Color)
				v.Particle["0"].CFrame *= CFrame.Angles(math.rad(1+1*math.cos(sine/i)),math.rad(1.2+1.4*math.cos(sine/i)),math.rad(1.4+1.2*math.cos(sine/i)))
				v.Beam.CurveSize0 = 1*math.cos(sine/13+i)
				v.Beam.CurveSize1 = -1*math.cos(sine/15+i)
			end
		end
	end)
end

-- Artificial Heartbeat --
local ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/60
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

-- Start of Loops --
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		sine += change
		sine2 += change
		sine3 += change
	end
end))
-- End of Loops --

-- Final Functions and variables --
function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 
local Anim="Idle"
-- Final Functions and variables end --

vpower = 1
local w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
local ap = 5*vpower
local p = .3

function cs(a)
	return(math.cos(sine/a))
end
function tw(frequency)
	local twitch = 0
	local x = math.random(1,frequency)
	if x == 1 then
		local y = math.random(1,2)
		if y == 1 then twitch = 1 else twitch = -1
		end
	end
	return(twitch)
end

local d = workspace:WaitForChild("LastStarMouseIgnore")
local leftlegheight,rightlegheight = 0,0

-- Final Loop
local coredistance = 1.5
while true do
	swait()
	if wing1 then
		local s = wing1.Secondary.Color
		local p = wing1.Primary.Color
		if core then
			if core:FindFirstChild("Base") then
				core.Base.Cyli.Color = s
				core.Base.Double.Color = p
				core.Base.Dupli.Color = p
				core.Base.Penta.Color = p
				core.Base.Cog.Color = s
				core.Base.Cyli.Centre.Particle.Color = ColorSequence.new(p)
				for i,v in pairs(core:GetDescendants()) do
					if v:IsA("Trail") then
						v.Color = ColorSequence.new(p)
					end
				end
			end
		end
	end
	if not plr then break end
	local humanoid = plr.Humanoid
	if humanoid.Health <= 0 then return end
	plr:WaitForChild("HumanoidRootPart",99999)
	local rootpart = plr.HumanoidRootPart
	local Walking = humanoid.MoveDirection.magnitude>0

	local vt = Vector3.new

	local FwdDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.lookVector or vt())
	local RigDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.rightVector or vt())

	local Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide

	local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
	local velderp=RootPart.Velocity.y
	hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,char)
	local Yvel = math.clamp(.5*root.Velocity.Y,-50,50)*vpower
	local shake = 0
	if fury.Value == true then
		shake = 1
	end
	function g()
		return(cf((math.random(-20,20)/30)*shake,(math.random(-20,20)/30)*shake,(math.random(-20,20)/30)*shake)*angles(math.rad((math.random(-20,20)/30)*shake),math.rad((math.random(-20,20)/30)*shake),math.rad((math.random(-20,20)/30)*shake)))
	end
	function furyshake()
		return(angles(math.rad((math.random(-120,120)/30)*shake),math.rad((math.random(-120,120)/30)*shake),math.rad((math.random(-120,120)/30)*shake)))
	end
	local a1,a2,a3,a4,a5,a6 = g(),g(),g(),g(),g(),g()
	local wing1offset = a1*cf(p*math.cos(sine/w1o),p*math.cos(sine/w1o+(w1o/6)),p*math.cos(sine/w1o+(w1o/3)))*angles(math.rad(ap*math.cos(sine/w1o+(w1o/4))),math.rad(-20*Vec.Z*vpower+ap*math.cos(sine/w1o+(w1o/7))),math.rad(-Yvel+ap*math.cos(sine/w1o+(w1o/2))))
	local wing2offset = a2*cf(p*math.cos(sine/w2o),p*math.cos(sine/w1o+(w2o/6)),p*math.cos(sine/w2o+(w2o/3)))*angles(math.rad(ap*math.cos(sine/w2o+(w2o/4))),math.rad(-20*Vec.Z*vpower+ap*math.cos(sine/w2o+(w2o/7))),math.rad(-Yvel+ap*math.cos(sine/w2o+(w2o/2))))
	local wing3offset = a3*cf(p*math.cos(sine/w3o),p*math.cos(sine/w1o+(w3o/6)),p*math.cos(sine/w3o+(w3o/3)))*angles(math.rad(ap*math.cos(sine/w3o+(w3o/4))),math.rad(-20*Vec.Z*vpower+ap*math.cos(sine/w3o+(w3o/7))),math.rad(-Yvel+ap*math.cos(sine/w3o+(w3o/2))))
	local wing4offset = a4*cf(p*math.cos(sine/w4o),p*math.cos(sine/w1o+(w4o/6)),p*math.cos(sine/w4o+(w4o/3)))*angles(math.rad(ap*math.cos(sine/w4o+(w4o/4))),math.rad(20*Vec.Z*vpower+ap*math.cos(sine/w4o+(w4o/7))),math.rad(Yvel+ap*math.cos(sine/w4o+(w4o/2))))
	local wing5offset = a5*cf(p*math.cos(sine/w5o),p*math.cos(sine/w1o+(w5o/6)),p*math.cos(sine/w5o+(w5o/3)))*angles(math.rad(ap*math.cos(sine/w5o+(w5o/4))),math.rad(20*Vec.Z*vpower+ap*math.cos(sine/w5o+(w5o/7))),math.rad(Yvel+ap*math.cos(sine/w5o+(w5o/2))))
	local wing6offset = a6*cf(p*math.cos(sine/w6o),p*math.cos(sine/w1o+(w6o/6)),p*math.cos(sine/w6o+(w6o/3)))*angles(math.rad(ap*math.cos(sine/w6o+(w6o/4))),math.rad(20*Vec.Z*vpower+ap*math.cos(sine/w6o+(w6o/7))),math.rad(Yvel+ap*math.cos(sine/w6o+(w6o/2))))
	
	root:WaitForChild("Theme")
	if wing1 ~= nil then
		if wing1:FindFirstChild("Core") then
			if wing1.Core:FindFirstChild("Spin") then
				wing1.Core.Spin.C0 = wing1.Core.Spin.C0*CFrame.Angles(0,0,math.rad(-7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing2.Core.Spin.C0 = wing2.Core.Spin.C0*CFrame.Angles(0,0,math.rad(-7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing3.Core.Spin.C0 = wing3.Core.Spin.C0*CFrame.Angles(0,0,math.rad(-7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing4.Core.Spin.C0 = wing4.Core.Spin.C0*CFrame.Angles(0,0,math.rad(7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing5.Core.Spin.C0 = wing5.Core.Spin.C0*CFrame.Angles(0,0,math.rad(7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing6.Core.Spin.C0 = wing6.Core.Spin.C0*CFrame.Angles(0,0,math.rad(7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
			end
		end
	end
	if core then
		local volume = (root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)
		local offset = cf(.3*cs(30.5),.3*cs(37.4),-coredistance+.3*cs(33.6))*angles(math.rad(2*cs(26.5)),math.rad(2*cs(28.3)),math.rad(2*cs(20.1)))
		coreweld.C0 = coreweld.C0:Lerp(offset,.02)
		penta.C0 = penta.C0*angles(0,0,math.rad(-4*volume))
		double.C0 = double.C0*angles(0,0,math.rad(6*volume))
		dupli.C0 = dupli.C0*angles(0,0,math.rad(-2*volume))
		cog.C0 = cog.C0*angles(0,0,math.rad(3*volume))
		cyli.C0 = cyli.C0*angles(0,0,math.rad(-1.75))
	end
	if hed:FindFirstChild("NameGui") then
		for y,x in pairs({hed.NameGui.LowerHalf.Vis1,hed.NameGui.LowerHalf.Vis2,hed.NameGui.LowerHalf.Vis3,hed.NameGui.LowerHalf.Vis4,hed.NameGui.LowerHalf.Vis5,hed.NameGui.LowerHalf.Vis6,hed.NameGui.LowerHalf.Vis7,hed.NameGui.LowerHalf.Vis8,hed.NameGui.LowerHalf.Vis9}) do
			x.Size = x.Size:Lerp(UDim2.new(0.045,0,math.clamp(0.7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/200)*math.random(90,110)/100,0,2),0),.5)
		end
		if fury.Value == true then
			local ft = {"Arcade","Antique","SciFi","Bodoni","Garamond","Oswald","Arial","Bangers","Cartoon","Code","Creepster","DenkOne","Fantasy","Fondamento","FredokaOne","GothamSemibold","GrenzeGotisch","Highway","IndieFlower","JosefinSans","Jura","Kalam","LuckiestGuy","Merriweather","Michroma","Nunito","PatrickHand","PermanentMarker","RobotoMono","Sarpanch","SourceSansSemibold","SpecialElite","Ubuntu","TitilliumWeb"}
			hed.NameGui.LowerHalf.FormName.Font = ft[math.random(1,#ft)]
			local l,a,s,t,r = {"L","L","_"},{"A","A","_"},{"S","S","_"},{"T","T","_"},{"R","R","_"}
			local funny = {"WORTHLESS","MEANINGLESS","POINTLESS","WHO★CARES?","FUTILE","FINAL★STAR","LAST★STAR?","FIRST★STAR","LAST★STAR",l[math.random(1,3)]..a[math.random(1,3)]..s[math.random(1,3)]..t[math.random(1,3)].."★"..s[math.random(1,3)]..t[math.random(1,3)]..a[math.random(1,3)]..r[math.random(1,3)]}
			local player = {string.upper(plr.Name),string.lower(plr.Name),"NOBODY","NO ONE","SOMEONE?"}
			hed.NameGui.LowerHalf.ScriptName.Text = funny[math.random(1,#funny)].." // "..player[math.random(1,5)]
		end
	end
	local Rray,Lray = Ray.new(rl.Position,rl.CFrame.UpVector.Unit*-2),Ray.new(ll.Position,ll.CFrame.UpVector.Unit*-2)
	local rp,Rpos = workspace:FindPartOnRayWithIgnoreList(Rray,{plr,d},false,true)
	local lp,Lpos = workspace:FindPartOnRayWithIgnoreList(Lray,{plr,d},false,true)
	leftlegheight,rightlegheight = 0,0
	if rp then   rightlegheight = (rl.Position-Rpos).Magnitude-.95   end
	if lp then   leftlegheight = (ll.Position-Lpos).Magnitude-.95   end
	if w1w ~= nil then
		if wingstyle.Value == "APEX" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(60+20*math.cos(sine/30))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(2,0,1)*angles(0,0,math.rad(90)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(120-20*math.cos(sine/30))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(-60-20*math.cos(sine/30))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-2,0,1)*angles(0,0,math.rad(-90)),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(-120+20*math.cos(sine/30))),lerp)
			height = 0
			coredistance = 1.5
		elseif wingstyle.Value == "PERDURANCE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(0,0,1)*angles(0,0,math.rad(0+3600*math.cos(sine/400))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(0,0,1)*angles(0,0,math.rad(72+3600*math.cos(sine/400))),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(0,0,1)*angles(0,0,math.rad(144+3600*math.cos(sine/400))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(0,0,1)*angles(0,0,math.rad(216+3600*math.cos(sine/400))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(0,0,1)*angles(0,0,math.rad(288+3600*math.cos(sine/400))),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(0,0,3)*angles(0,0,math.rad(-1800*math.cos(sine/400))),lerp)
			height = 2+1*cs(57)
			coredistance = 2
		elseif wingstyle.Value == "REPRESSION" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(60+20*math.cos(sine/30))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(20,0,1)*angles(0,0,math.rad(-90)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(120-20*math.cos(sine/30))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(-60-20*math.cos(sine/30))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-20,0,1)*angles(0,0,math.rad(90)),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(-120+20*math.cos(sine/30))),lerp)
			height = 0
			coredistance = 1.5
		elseif wingstyle.Value == "EXECUTION" or wingstyle.Value == "ANARCHY" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(2,1,1)*angles(0,0,math.rad(10+10*math.cos(sine/40))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(5,1.6+.4*math.cos(sine2/40),1)*angles(0,0,math.rad(30+20*math.cos(sine2/40))),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(7,3.5+1.25*math.cos(sine3/40),1)*angles(0,0,math.rad(50+40*math.cos(sine3/40))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-2,1,1)*angles(0,0,math.rad(-10-10*math.cos(sine/40))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-5,1.6+.4*math.cos(sine2/40),1)*angles(0,0,math.rad(-30-20*math.cos(sine2/40))),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-7,3.5+1.25*math.cos(sine3/40),1)*angles(0,0,math.rad(-50-40*math.cos(sine3/40))),lerp)
			height = 5-1*math.cos(sine/40)
			coredistance = 1.5
		elseif wingstyle.Value == "VINDICTIVE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*angles(0,0,math.rad(0+3600*math.cos(sine/800)))*cf(0,-5,1)*angles(0,0,math.rad(60)),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*angles(0,0,math.rad(120+3600*math.cos(sine/800)))*cf(0,-5,1)*angles(0,0,math.rad(60)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*angles(0,0,math.rad(240+3600*math.cos(sine/800)))*cf(0,-5,1)*angles(0,0,math.rad(60)),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*angles(0,0,math.rad(60))*cf(0,-3,2),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*angles(0,0,math.rad(60+120))*cf(0,-3,2),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*angles(0,0,math.rad(60+240))*cf(0,-3,2),lerp)
			height = 5+1*math.cos(sine/40)
			coredistance = 2.5
		elseif wingstyle.Value == "NIHIL" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,-10,1)*wing1offset*angles(0,0,math.rad(3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w2w.C0 = w2w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,-10,1)*wing2offset*angles(0,0,math.rad(120+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w3w.C0 = w3w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,-10,1)*wing3offset*angles(0,0,math.rad(240+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w4w.C0 = w4w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,10,1)*wing4offset*angles(0,0,math.rad(3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w5w.C0 = w5w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,10,1)*wing5offset*angles(0,0,math.rad(120+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w6w.C0 = w6w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,10,1)*wing6offset*angles(0,0,math.rad(240+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			height = 8+1*math.cos(sine/40)
			coredistance = 2
		elseif wingstyle.Value == "TEMPEST" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*angles(0,0,math.rad(0+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*angles(0,0,math.rad(40+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*angles(0,0,math.rad(-40+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*angles(0,0,math.rad(180+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*angles(0,0,math.rad(220+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*angles(0,0,math.rad(140+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			height = 5+.5*math.cos(sine/40)
			coredistance = 1.5
		elseif wingstyle.Value == "INFERNUM" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(2.5,0+.25*math.cos(sine/30),1)*angles(0,0,math.rad(90+10*math.cos(sine/30))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(14,13,1)*angles(0,0,math.rad(-90))*angles(0,0,math.rad(45)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(1.5,2.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(45+120-10*math.cos(sine/30))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-2.5,-0+.25*math.cos(sine/30),1)*angles(0,0,math.rad(-90-10*math.cos(sine/30))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-14,13,1)*angles(0,0,math.rad(90))*angles(0,0,math.rad(-45)),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-1.5,2.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(-45-120+10*math.cos(sine/30))),lerp)
			height = 0
			coredistance = 1.5
		elseif wingstyle.Value == "VIRTUE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(0,0,1)*angles(0,0,math.rad(0+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(0,0,1)*angles(0,0,math.rad(90+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(0,0,1)*angles(0,0,math.rad(180+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(0,0,1)*angles(0,0,math.rad(270+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(0,0,2)*angles(0,0,math.rad(-1800*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(0,0,2)*angles(0,0,math.rad(180-1800*math.cos(sine/800)))*cf(0,-2,0),lerp)
			height = 0
			coredistance = 2
		elseif wingstyle.Value == "DISSONANCE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(0,0,1)*angles(0,0,math.rad(45)),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(0,0,1)*angles(0,0,math.rad(45+180)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(0,0,1)*angles(0,0,math.rad(-45)),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(0,0,1)*angles(0,0,math.rad(-45+180)),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(0,0,2)*angles(0,0,math.rad(90+45*math.cos(sine/100))),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(0,0,2)*angles(0,0,math.rad(90+180+45*math.cos(sine/100))),lerp)
			height = 4+1*math.cos(sine/60)
			coredistance = 1.5
		elseif wingstyle.Value == "ABSOLUTION" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(sine+3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(sine+120+3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(sine+240+3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(sine-3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(sine+120-3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(sine+240-3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			height = 8+1*cs(45)
			coredistance = 2.5
		elseif wingstyle.Value == "WARPSPEED" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,1.5)*wing1offset*angles(0,0,math.rad(90+22.5+22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,1.5)*wing2offset*angles(0,0,math.rad(90-22.5-22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,1.5)*wing3offset*angles(0,0,math.rad(-90+22.5+22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,1.5)*wing4offset*angles(0,0,math.rad(-90-22.5-22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,1.5)*wing5offset*angles(0,0,math.rad(0))*cf(0,1+1*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,1.5)*wing6offset*angles(0,0,math.rad(180))*cf(0,1+1*cs(40),0),lerp)
			height = 0
			coredistance = 2
		elseif wingstyle.Value == "INTRICACY" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,1.5)*wing1offset*angles(0,0,math.rad(90))*cf(0,-1+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,1.5)*wing2offset*angles(0,0,math.rad(-90))*cf(0,-1+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,1.5)*wing3offset*angles(0,0,math.rad(900*cs(600)))*cf(0,-1+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,1.5)*wing4offset*angles(0,0,math.rad(1800*cs(600)))*cf(0,-1+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,1.5)*wing5offset*angles(0,0,math.rad(2700*cs(600)))*cf(0,1+1*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,1.5)*wing6offset*angles(0,0,math.rad(3600*cs(600)))*cf(0,1+1*cs(40),0),lerp)
			height = 3+1*cs(33)
			coredistance = 2
		elseif wingstyle.Value == "APOCALYPSE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,1.5)*wing1offset*angles(0,0,math.rad(90+180*cs(200)))*cf(0,-2+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,1.5)*wing2offset*angles(0,0,math.rad(-90-180*cs(200)))*cf(0,-2+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,1.5)*wing3offset*angles(0,0,math.rad(-90-1800*cs(400)))*cf(0,-2+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,1.5)*wing4offset*angles(0,0,math.rad(-90+1800*cs(400)))*cf(0,-2+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,1.5)*wing5offset*angles(0,0,math.rad(90+1800*cs(400)))*cf(0,-1+1*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,1.5)*wing6offset*angles(0,0,math.rad(90-1800*cs(400)))*cf(0,-1+1*cs(40),0),lerp)
			height = 4.5+1*cs(30)
			coredistance = 2
		elseif wingstyle.Value == "SAGITTARIUS" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			local x = 5
			local y = -10
			local z = 20
			w1w.C0 = w1w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(-3600*cs(600)+60))*cf(0,-y+z*cs(100)+x,0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(-3600*cs(600)+120))*cf(0,-y+z*cs(100)+x,0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(-3600*cs(600)+180))*cf(0,-y+z*cs(100)+x,0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(-3600*cs(600)+240))*cf(0,-y+z*cs(100)+x,0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(-3600*cs(600)+300))*cf(0,-y+z*cs(100)+x,0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(-3600*cs(600)+360))*cf(0,-y+z*cs(100)+x,0),lerp)
			w7w.C0 = w7w.C0:lerp(cf(0,0,4)*wing1offset*angles(0,0,math.rad(3600*cs(600)+60+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w8w.C0 = w8w.C0:lerp(cf(0,0,4)*wing2offset*angles(0,0,math.rad(3600*cs(600)+120+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w9w.C0 = w9w.C0:lerp(cf(0,0,4)*wing3offset*angles(0,0,math.rad(3600*cs(600)+180+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w10w.C0 = w10w.C0:lerp(cf(0,0,4)*wing4offset*angles(0,0,math.rad(3600*cs(600)+240+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w11w.C0 = w11w.C0:lerp(cf(0,0,4)*wing5offset*angles(0,0,math.rad(3600*cs(600)+300+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w12w.C0 = w12w.C0:lerp(cf(0,0,4)*wing6offset*angles(0,0,math.rad(3600*cs(600)+360+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			height = 14+2*cs(50)
			coredistance = 5
		elseif wingstyle.Value == "HARMONY" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			local x = 5
			local y = -10
			local z = 20
			w1w.C0 = w1w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500))),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500)+180)),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(120-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500))),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(120-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500)+180)),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(240-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500))),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(240-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500)+180)),lerp)
			w7w.C0 = w7w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(3600*cs(600)+30*cs(100)))*cf(0,10,0),lerp)
			w8w.C0 = w8w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(3600*cs(600)+30*cs(100)+180))*cf(0,-10,0),lerp)
			w9w.C0 = w9w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(120+3600*cs(600)+30*cs(100)))*cf(0,10,0),lerp)
			w10w.C0 = w10w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(120+3600*cs(600)+30*cs(100)+180))*cf(0,-10,0),lerp)
			w11w.C0 = w11w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(240+3600*cs(600)+30*cs(100)))*cf(0,10,0),lerp)
			w12w.C0 = w12w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(240+3600*cs(600)+30*cs(100)+180))*cf(0,-10,0),lerp)
			height = 18+2*cs(50)
			coredistance = 2
		end
	end
	
	if Torso:FindFirstChild("Neck") then
		if anim.Value == "STARTUP" then
			g = .05
			RootJoint.C0 = RootJoint.C0:Lerp(RootCF*cf(0,0.3,0)*angles(math.rad(-5.9),math.rad(0),math.rad(-30.7)),g)
			Torso.Neck.C0 = Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-6.5),math.rad(-6.1),math.rad(28.8)),g)
			LS.C0 = LS.C0:Lerp(cf(-1.4,0.9,-0.9)*angles(math.rad(160.4),math.rad(31),math.rad(-2.3)),g)
			RS.C0 = RS.C0:Lerp(cf(1.5,0.6,0.2)*angles(math.rad(2.1),math.rad(-15.2),math.rad(18.6)),g)
			LH.C0 = LH.C0:Lerp(cf(-0.9,-1,0)*angles(math.rad(-8.7),math.rad(20.1),math.rad(-7.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),g)
			RH.C0 = RH.C0:Lerp(cf(0.9,-0.9,0.1)*angles(math.rad(-5.6),math.rad(-24.4),math.rad(12.2))*angles(math.rad(0),math.rad(90),math.rad(0)),g)
		end
		if RootPart.Velocity.y > 1 and hitfloor==nil and root.Anchored==false then
			Anim="Jump"
			local lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height)*angles(math.rad(-4.5),math.rad(0),math.rad(0)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(18.3),math.rad(0),math.rad(0)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.7,0.6,0)*angles(math.rad(24.5),math.rad(0),math.rad(-18.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.5,-0.1)*angles(math.rad(24.5),math.rad(0),math.rad(19.3)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,-0.1)*angles(math.rad(-10.8),math.rad(14.5),math.rad(-2.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.1,-0.8)*angles(math.rad(-36.8),math.rad(-31.4),math.rad(6.3))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif RootPart.Velocity.y < -1 and hitfloor==nil and root.Anchored==false then 
			Anim="Fall"
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(cf(0,height,0)*angles(math.rad(-5),math.rad(0),math.rad(0))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(15)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1,-1,-0.3)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(85),math.rad(0)),Alpha)
			LS.C0 = LS.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(-5),math.rad(0),math.rad(-35)),Alpha)
			RS.C0 = RS.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(-5),math.rad(0),math.rad(35)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,.4)*angles(math.rad(-15),math.rad(0),math.rad(0))*necko,Alpha)
		end
		if torvel>15 and torvel <= 25 and hitfloor~=nil and height == 0 and root.Anchored==false then
			Anim="Walk"
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/5)+.1*math.sin(sine/5))*angles(math.rad(8*Vec.Z+5*math.cos(sine/5)),math.rad(-8*Vec.X),math.rad(8*math.cos(sine/10))),.1)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(-5*Vec.Z-3*math.cos(sine / 5)+3*math.sin(sine / 5)),math.rad(5*Vec.X),math.rad(-7*math.cos(sine/10))),.1)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5+.1*math.cos(sine/5),.6*math.cos(sine/10)*Vec.Z)*angles(math.rad(-50*math.cos(sine / 10)*Vec.Z),0,math.rad(2.5+2.5*math.sin(sine/-5)-8*math.cos(sine/10)*Vec.X)),.1)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5+.1*math.cos(sine/5),-.6*math.cos(sine/10)*Vec.Z)*angles(math.rad(50*math.cos(sine / 10)*Vec.Z),0,math.rad(-2.5-2.5*math.sin(sine/-5)+8*math.cos(sine/10)*Vec.X)),.1)
			RH.C0=RH.C0:Lerp(cf(1,-1+.2*math.sin(sine/-10),0-.25*math.cos(sine/10)*Vec.Z-0.2*math.cos(sine/10)*Vec.X)*angles(0,math.rad(90),0)*angles(math.rad(-20*math.cos(sine/10)*Vec.X),math.rad(-8*math.cos(sine/10)),math.rad(35*math.cos(sine / 10)*Vec.Z)),.1)
			LH.C0=LH.C0:Lerp(cf(-1,-1+.2*math.sin(sine/10),0+.25*math.cos(sine/10)*Vec.Z-0.2*math.cos(sine/10)*Vec.X)*angles(0,math.rad(-90),0)*angles(math.rad(-20*math.cos(sine/10)*Vec.X),math.rad(-8*math.cos(sine/10)),math.rad(35*math.cos(sine / 10)*Vec.Z)),.1)
		end
		if torvel>1 and torvel <= 15 and hitfloor~=nil and height == 0 and root.Anchored==false then
			Anim="Walk"
			local m = 14
			local n = m/2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/n)+.1*math.sin(sine/n))*angles(math.rad(8*Vec.Z+2*math.cos(sine/n)),math.rad(-8*Vec.X),math.rad(8*math.cos(sine/m))),.1)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(10-5*Vec.Z+3*math.sin(sine / n)),math.rad(5*Vec.X),math.rad(-7*math.cos(sine/m))),.1)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5+.1*math.cos(sine/n),.3*math.cos(sine/m)*Vec.Z)*angles(math.rad(-40*math.cos(sine / m)*Vec.Z),0,math.rad(2.5+2.5*math.sin(sine/-n)-8*math.cos(sine/m)*Vec.X)),.1)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5+.1*math.cos(sine/n),-.3*math.cos(sine/m)*Vec.Z)*angles(math.rad(40*math.cos(sine / m)*Vec.Z),0,math.rad(-2.5-2.5*math.sin(sine/-n)+8*math.cos(sine/m)*Vec.X)),.1)
			RH.C0=RH.C0:Lerp(cf(1,-1+.15*math.sin(sine/-m),0-.05*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(25*math.cos(sine / m)*Vec.Z)),.1)
			LH.C0=LH.C0:Lerp(cf(-1,-1+.15*math.sin(sine/m),0+.05*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(-90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(25*math.cos(sine / m)*Vec.Z)),.1)
		end
		if torvel>25 and hitfloor~=nil and height == 0 and root.Anchored==false then
			Anim="Walk"
			local lerp = .3
			local m = 6
			local n = m/2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/n)+.05*math.sin(sine/n))*angles(math.rad(10+20*Vec.Z+3*math.cos(sine/n)),math.rad(-14*Vec.X),math.rad(4*math.cos(sine/m))),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(-20*Vec.Z-7*math.cos(sine / n)),math.rad(5*Vec.X),math.rad(-3*math.cos(sine/m))),lerp)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5+.2*math.cos(sine/n),.8*math.cos(sine/m)*Vec.Z)*angles(math.rad(10-75*math.cos(sine /m)*Vec.Z),0,math.rad(5-8*math.cos(sine/m)*Vec.X)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5+.2*math.cos(sine/n),-.8*math.cos(sine/m)*Vec.Z)*angles(math.rad(10+75*math.cos(sine /m)*Vec.Z),0,math.rad(-5+8*math.cos(sine/m)*Vec.X)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-.8+.5*math.sin(sine/-m),0-.25*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m)*Vec.Z)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-.8+.5*math.sin(sine/m),0+.25*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(-90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m)*Vec.Z)),lerp)
		end
		if height > 0 and torvel>1 and hitfloor~=nil and root.Anchored==false then
			Anim="Walk"
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height)*angles(math.rad(0 + 55*Vec.Z + 5 * math.cos(sine / 20)),math.rad(0 - 25*Vec.X),math.rad(0 * math.cos(sine / 10))),.1)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(0 - 40*Vec.Z + 5  * math.cos(sine / 20)),math.rad(0 + 0 * math.cos(sine / 5)),math.rad(0 - 0 * math.cos(sine / 10))),.1)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5,0)*angles(math.rad(-10+2*math.cos(sine/22)),math.rad(-15+2*math.cos(sine/26)),math.rad(15+2*math.cos(sine/26))),.1)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5,0)*angles(math.rad(-10+2*math.cos(sine/24)),math.rad(15+2*math.cos(sine/24)),math.rad(-15+2*math.cos(sine/22))),.1)
			RH.C0=RH.C0:Lerp(cf(1,-0.3,-0.5)*angles(0,math.rad(90),0)*angles(0,0,math.rad(-15+2*math.cos(sine/20))),.1)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(0,math.rad(-90),0)*angles(0,0,math.rad(10+2*math.cos(sine/24))),.1)
		end
		if torvel<1 and hitfloor~=nil then
			if anim.Value == "APEX" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				local h = 30
				local g = h*2
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.sin(sine/g),0,0+.1*math.cos(sine/h))*angles(math.rad(-9.6),math.rad(-4.7+5*math.sin(sine/g)),math.rad(29.2)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(16.1+6*math.cos(sine/25)),math.rad(0+3*math.cos(sine/28)),math.rad(-24.3+3*math.cos(sine/h))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,0.6-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(-9.5),math.rad(0),math.rad(-20.2-10*math.sin(sine/h))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,0.6-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(22.7+10*math.sin(sine/h))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1+.1*math.sin(sine/g),-.8-.1*math.cos(sine/h)+.05*math.sin(sine/g)-leftlegheight,0.1)*angles(math.rad(-26.6),math.rad(23.2),math.rad(-9.5-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9+.1*math.sin(sine/g),-1-.1*math.cos(sine/h)-.05*math.sin(sine/g)-rightlegheight,-0.3)*angles(math.rad(-1.8),math.rad(-20.1),math.rad(17.4-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "DOWNFALL" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				local h = 30
				local g = h*2
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.sin(sine/g),0,0+.1*math.cos(sine/h))*angles(math.rad(-9.6),math.rad(-4.7+5*math.sin(sine/g)),math.rad(29.2)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(30+6*math.cos(sine/25)),math.rad(0+3*math.cos(sine/28)),math.rad(-24.3+3*math.cos(sine/h))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,0.3-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(-15),math.rad(30),math.rad(40)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,0.3-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(-15),math.rad(-30),math.rad(-40)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1+.1*math.sin(sine/g),-.8-.1*math.cos(sine/h)+.05*math.sin(sine/g)-leftlegheight,0.1)*angles(math.rad(-26.6),math.rad(23.2),math.rad(-9.5-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9+.1*math.sin(sine/g),-1-.1*math.cos(sine/h)-.05*math.sin(sine/g)-rightlegheight,-0.3)*angles(math.rad(-1.8),math.rad(-20.1),math.rad(17.4-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "EXASPERATION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 - .15 * math.sin(sine/40),0)*angles(math.rad(12.3),math.rad(44.3),math.rad(-8.6))*RootCF,lerp)
				Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*furyshake()*angles(math.rad(17.9 +5 * math.cos(sine/40) + math.random(-2,2)),math.rad(-6.4+ math.random(-2,2)),math.rad(-38.5+ math.random(-2,2))),.2)
				LS.C0 = LS.C0:lerp(cf(-1.5,0.3+.1 * math.cos(sine/40),0.2)*furyshake()*angles(math.rad(8.3),math.rad(25.8),math.rad(-22)),lerp)
				RS.C0 = RS.C0:lerp(cf(1.5,0.2+.1 * math.cos(sine/40),0.4)*furyshake()*angles(math.rad(-5.8),math.rad(-32.8),math.rad(18.9)),lerp)
				LH.C0 = LH.C0:lerp(cf(-1,-1+.15 * math.sin(sine/40),0)*angles(math.rad(-11.4),math.rad(8.9),math.rad(-9.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0 = RH.C0:lerp(cf(1,-1+.15 * math.sin(sine/40),0)*angles(math.rad(-15.6),math.rad(-33.9),math.rad(6.3))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "PERDURANCE" then
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(80),1*cs(100),height)*angles(math.rad(-1.2+5*cs(45)),math.rad(42.5+5*cs(65)),math.rad(-46.3+5*cs(51))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(40.9+3*cs(47)),math.rad(-30.3+5*cs(43)),math.rad(58.8+3*cs(41))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.2,0.3+.1*math.sin(57),-0.6)*furyshake()*angles(math.rad(109.1+10*math.sin(sine/57)),math.rad(23.2+10*math.sin(sine/57)),math.rad(24.9)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,0.3+.1*math.sin(57),0)*furyshake()*angles(math.rad(-4.6),math.rad(14.9),math.rad(71.9+20*math.sin(sine/57))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-0.9,0.1)*angles(math.rad(-8.3+5*cs(50)),math.rad(10.4+5*cs(62)),math.rad(-7+5*cs(64)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-0.3+.2*cs(47),-0.8)*angles(math.rad(-12.1+10*cs(50)),math.rad(-9.6+5*cs(44)),math.rad(5+5*cs(49)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "REPRESSION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.cos(sine/40),0,-0.2+.1*math.cos(sine/30))*angles(math.rad(19.2),math.rad(0+5*math.cos(sine/40)),math.rad(-30.1)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(-18.3+6*math.cos(sine/25)),math.rad(1.2+3*math.cos(sine/28)),math.rad(27.8+3*math.cos(sine/32))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.7+.1*math.cos(sine/34),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(-90-10*math.cos(sine/35))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.7+.1*math.cos(sine/34),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(90+10*math.cos(sine/35))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1,-0.8+.1*math.cos(sine/40)-.1*math.cos(sine/30)-leftlegheight,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.8,-1.2-.1*math.cos(sine/40)-.1*math.cos(sine/30)-rightlegheight,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "ADMISSION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.cos(sine/40),0,-0.2+.1*math.cos(sine/30))*angles(math.rad(19.2),math.rad(0+5*math.cos(sine/40)),math.rad(-30.1)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(6*math.cos(sine/25)),math.rad(1.2+3*math.cos(sine/28)),math.rad(-5+3*math.cos(sine/32))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.1-.07*math.sin(sine/30),.4)*furyshake()*angles(math.rad(15),math.rad(-30),math.rad(40)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1-.07*math.sin(sine/30),.4)*furyshake()*angles(math.rad(15),math.rad(30),math.rad(-40)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1,-0.8+.1*math.cos(sine/40)-.1*math.cos(sine/30)-leftlegheight,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.8,-1.2-.1*math.cos(sine/40)-.1*math.cos(sine/30)-rightlegheight,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "EXECUTION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(70),1*cs(80),5-1*math.cos(sine/50))*angles(math.rad(-10+5*math.cos(sine/35)),math.rad(-30+5*math.cos(sine/37)),math.rad(67.6+5*math.cos(sine/42))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30+5*math.cos(sine/36)),math.rad(-10+5*math.cos(sine/33)),math.rad(-67.6+5*math.cos(sine/39))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,-0.3+.2*math.cos(sine/35),-0.2)*furyshake()*angles(math.rad(113.9+8*math.cos(sine/41)),math.rad(25.4+5*math.cos(sine/39)),math.rad(0+5*math.cos(sine/37))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.4,-0.1)*furyshake()*angles(math.rad(1.3+5*math.cos(sine/36)),math.rad(16.4+5*math.cos(sine/38)),math.rad(81.6+5*math.cos(sine/33))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,-0.1)*angles(math.rad(-64.9+20*math.cos(sine/38)),math.rad(12+5*math.cos(sine/44)),math.rad(-6.9+5*math.cos(sine/36)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,0+.25*math.cos(sine/43),-0.7)*angles(math.rad(-19+5*math.cos(sine/30)),math.rad(-16.2+5*math.cos(sine/38)),math.rad(7.5+5*math.cos(sine/45)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "STIGMA" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(70),1*cs(80),5-1*math.cos(sine/50))*angles(math.rad(-10+5*math.cos(sine/35)),math.rad(-30+5*math.cos(sine/37)),math.rad(67.6+5*math.cos(sine/42))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30+5*math.cos(sine/36)),math.rad(-10+5*math.cos(sine/33)),math.rad(-67.6+5*math.cos(sine/39))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.2,-0.4-.15*math.sin(sine/50),-0.3)*furyshake()*angles(math.rad(119.3-20*math.sin(sine/50)),math.rad(66.3),math.rad(-0.5)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.6+.15*math.sin(sine/50),-0.6)*furyshake()*angles(math.rad(131.8),math.rad(26.6),math.rad(37)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-1-.1*math.sin(sine/50),-0.3)*angles(math.rad(-29.5+10*math.cos(sine/50)),math.rad(5.8+5*math.cos(sine/30)),math.rad(-12.6+5*math.cos(sine/48)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,0+.25*math.cos(sine/43),-0.7)*angles(math.rad(-19+5*math.cos(sine/30)),math.rad(-16.2+5*math.cos(sine/38)),math.rad(7.5+5*math.cos(sine/45)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "VINDICTIVE" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(75),1*cs(80),5+1*math.cos(sine/60))*angles(math.rad(-15.9+7*cs(50)),math.rad(-4.5+5*cs(47)),math.rad(23.8+5*cs(52))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(20.8+5*cs(46)),math.rad(5.1+3*cs(55)),math.rad(-23.8+3*cs(47))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.7,0.8,-0.1)*furyshake()*angles(math.rad(-3.4+5*cs(44)),math.rad(-5.5+5*cs(57)),math.rad(-42.2+20*cs(47))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.2,0.8+.2*cs(57),-0.5)*furyshake()*angles(math.rad(170.6),math.rad(3),math.rad(-19.1)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(math.rad(0+5*cs(47)),math.rad(0+5*cs(39)),math.rad(10*cs(55)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,-0.2+.4*cs(58),-1)*angles(math.rad(-30.4+5*cs(48)),math.rad(-11.9+5*cs(52)),math.rad(4.8+5*cs(58)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "NIHIL" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(70),1*cs(60),8+1*math.cos(sine/50))*angles(math.rad(-8.3+5*math.cos(sine/37)),math.rad(0+5*math.cos(sine/33)),math.rad(51.1+5*math.cos(sine/42))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(-0,0,0)*furyshake()*angles(math.rad(14.5+5*math.cos(sine/25)),math.rad(-11.3+2*math.cos(sine/28)),math.rad(-45.8+2*math.cos(sine/24))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.5+.1*math.cos(sine/36),0.5)*furyshake()*angles(math.rad(-7.2),math.rad(-26.6),math.rad(40.4)),lerp)
				RS.C0=RS.C0:Lerp(cf(1,0.4+.1*math.cos(sine/36),0.8)*furyshake()*angles(math.rad(-14.8),math.rad(16.4),math.rad(-45.8)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-2.9+5*math.cos(sine/33)),math.rad(10.2+5*math.cos(sine/29)),math.rad(-9.7+5*math.cos(sine/40)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.8,-0.1+.2*math.cos(sine/39),-0.7)*angles(math.rad(-6.2+5*math.cos(sine/42)),math.rad(-13.9+5*math.cos(sine/41)),math.rad(8.9+5*math.cos(sine/37)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "ANARCHY" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(80),1*cs(60),5+1*cs(30))*angles(math.rad(-35.3+7*cs(55)),math.rad(-20.1+7*cs(56)),math.rad(31.2+7*cs(48))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(38.9+3+5*cs(53)),math.rad(-5+3*cs(48)),math.rad(-32.3+3*cs(61))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.3,0.2+.2*cs(47),-0.5)*furyshake()*angles(math.rad(63.9),math.rad(-18.1),math.rad(67.1)),lerp)
				RS.C0=RS.C0:Lerp(cf(1,0.5+.2*cs(47),0.8)*furyshake()*angles(math.rad(-53.1),math.rad(-13.8),math.rad(-63.6)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.8,-0.2)*angles(math.rad(-43.3+5*cs(56)),math.rad(13.6+5*cs(58)),math.rad(-14.6+5*cs(53)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1.1,-0.7+.4*cs(45),-1.3)*angles(math.rad(-55.1+5*cs(48)),math.rad(-21.2+5*cs(55)),math.rad(9.4+5*cs(52)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "TEMPEST" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(67),1*cs(57),5+.5*math.cos(sine/40))*angles(math.rad(0+5*math.cos(sine/36)),math.rad(0+5*math.cos(sine/60)),math.rad(-46.2+5*math.cos(sine/45))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(9.8+5*math.cos(sine/37)),math.rad(-11.4+3*math.cos(sine/39)),math.rad(46.6+3*math.cos(sine/42))),lerp)
				LS.C0=LS.C0:Lerp(cf(-0.5,0.5+.1*math.cos(sine/42),-0.6)*furyshake()*angles(math.rad(96.3),math.rad(-9.8),math.rad(76.2)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.6+.1*math.cos(sine/42),-0.5)*furyshake()*angles(math.rad(-158),math.rad(-9.9),math.rad(-28.1)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(math.rad(5*math.cos(sine/38)),math.rad(5*math.cos(sine/44)),math.rad(5*math.cos(sine/37)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,-0.2+.3*math.cos(sine/38),-0.9)*angles(math.rad(-25.8+5*math.cos(sine/37)),math.rad(5*math.cos(sine/46)),math.rad(5*math.cos(sine/49)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "INFERNUM" then
				Anim="Idle"
				local lerp = .05
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.1+.1*cs(50),.6,-0.7+.15*cs(45))*angles(0,math.rad(5*cs(50)),0)*angles(math.rad(-25),math.rad(10.4),math.rad(-23.1)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30.8+5*cs(46)),math.rad(-14.4+3*cs(43)),math.rad(19+5*cs(50)+3*cs(47))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.3+.2*cs(43),0.2)*furyshake()*angles(math.rad(20*cs(48)-24.1+5*cs(44)),math.rad(0+5*cs(48)),math.rad(0)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.3+.2*cs(43),0.2)*furyshake()*angles(math.rad(20*cs(48)-24.1+5*cs(42)),math.rad(0+5*cs(52)),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1+.1*cs(50),-0.8-.15*cs(45)-leftlegheight,-0.7)*angles(math.rad(-11.4),math.rad(26.7),math.rad(-13.5-5*cs(50)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.7+.1*cs(50),-1.1-.15*cs(45)-rightlegheight,-0.6)*angles(math.rad(-58.6),math.rad(-16.9),math.rad(11-5*cs(50)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "VIRTUE" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0.1*math.sin(sine/50),0,0+.1*cs(25))*angles(0,math.rad(5*math.sin(sine/50)),0)*angles(math.rad(0),math.rad(0),math.rad(-56.9)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(0),math.rad(-9+5*cs(50)),math.rad(54.6)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.7,0.4+.2*cs(28),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(-32.7-15*math.sin(sine/28))),lerp)
				RS.C0=RS.C0:Lerp(cf(0.6,-0.1,-0.7)*furyshake()*angles(math.rad(174.2+5*cs(50)),math.rad(-3),math.rad(-19.7-5*cs(50))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1-0.1*math.sin(sine/50),-1+.05*math.sin(sine/50)-.1*cs(25)-leftlegheight,0.3)*angles(math.rad(8.8+5*math.sin(sine/50)),math.rad(32.4),math.rad(-11.8-5*math.sin(sine/50)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1-0.05*math.sin(sine/50),-1-.05*math.sin(sine/50)-.1*cs(25)-rightlegheight,-0.2)*angles(math.rad(-17.7-5*math.sin(sine/50)),math.rad(-15.7),math.rad(12.3))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "ABSOLUTION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(65),1*cs(70),height)*angles(0,math.rad(10*math.sin(sine/90)),0)*angles(math.rad(-12.2+5*cs(48)),math.rad(5*cs(50)),math.rad(-45.2+5*cs(40))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(20.1),math.rad(17.6-10*math.sin(sine/90)),math.rad(37.1)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.4+.2*cs(56),-0.3)*furyshake()*angles(math.rad(81.7+10*cs(50)),math.rad(13.8+3*cs(47)),math.rad(58.9+3*cs(40))),lerp)
				RS.C0=RS.C0:Lerp(cf(0.9,0.3+.2*cs(56),-0.8)*furyshake()*angles(math.rad(68.7+10*cs(50)),math.rad(7+3*cs(53)),math.rad(-71+3*cs(59))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4+.2*cs(46),-1.1)*angles(math.rad(-54.9+10*cs(42)),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1+.1*cs(49),-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "RETENTION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(65),1*cs(70),height)*angles(0,math.rad(10*math.sin(sine/90)),0)*angles(math.rad(12.2+5*cs(48)),math.rad(5*cs(50)),math.rad(-45.2+5*cs(40))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30.1),math.rad(17.6-10*math.sin(sine/90)),math.rad(37.1)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.4,1,-0.5)*angles(math.rad(122.9),math.rad(16.4),math.rad(54.8)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1-.07*math.sin(sine/30),.4)*furyshake()*angles(math.rad(15),math.rad(30),math.rad(-40)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4+.2*cs(46),-1.1)*angles(math.rad(-54.9+10*cs(42)),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1+.1*cs(49),-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "DISSONANCE" then
				Anim="Idle"
				local lerp = .05
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(2*cs(80),height,2*cs(130))*angles(math.rad(51.5+5*cs(70)),math.rad(0),math.rad(0))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.6,0.8)*furyshake()*angles(math.rad(-61.2-5*math.sin(sine/60)),math.rad(3*cs(50)),math.rad(3*cs(85)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.7,0.3-.3*math.sin(sine/60))*furyshake()*angles(math.rad(-51.3),math.rad(0),math.rad(0)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.7,0.3-.3*math.sin(sine/60))*furyshake()*angles(math.rad(-51.3),math.rad(0),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,0.1,-1)*angles(math.rad(-17.7-10*math.sin(sine/60)),math.rad(4.8),math.rad(7.8))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-30.4),math.rad(13.8),math.rad(-8.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "WARPSPEED" then
				Anim = "Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(0,-0.5+.1*cs(32),0)*angles(math.rad(-43.5+5*math.sin(sine/32)),math.rad(26.7),math.rad(0))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.3,0.3,-0.6)*furyshake()*angles(math.rad(37+5*math.sin(sine/32)),math.rad(-17.1+3*cs(43)),math.rad(19.9+3*cs(68)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.3,0.7+.1*math.sin(sine/32),-0.9)*furyshake()*angles(math.rad(115.8-10*math.sin(sine/32)),math.rad(12),math.rad(-53.8)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,0.1+.1*math.sin(sine/32),0.2)*furyshake()*angles(math.rad(7.1),math.rad(13.6),math.rad(-64.4-10*math.sin(sine/32))),lerp)
				RH.C0=RH.C0:Lerp(cf(1.2,0-.05*cs(32)-.05*math.sin(sine/32)-rightlegheight,-0.2-.05*cs(32)+.05*math.sin(sine/32))*angles(math.rad(50.1-5*math.sin(sine/32)),math.rad(-20.6),math.rad(22.8))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.7-.05*cs(32)-.05*math.sin(sine/32)-leftlegheight,-0.6-.05*cs(32)+.05*math.sin(sine/32))*angles(math.rad(6.6-5*math.sin(sine/32)),math.rad(6.3),math.rad(-7.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "APOCALYPSE" then
				Anim = "Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(49),height,1*cs(80))*angles(math.rad(-29.7-10*math.sin(sine/30)),math.rad(-31.7+5*cs(60)),math.rad(5*cs(70)))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0,-0.2)*furyshake()*angles(math.rad(20.4+10*math.sin(sine/30)),math.rad(33.4+7*cs(37)),math.rad(-11.6+7*cs(55)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,-0.4+.2*math.sin(sine/30),-0.1)*furyshake()*angles(math.rad(-151+10*math.sin(sine/30)),math.rad(-46.1),math.rad(34.5-20*cs(30))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,-0.3+.2*math.sin(sine/30),-0.6)*furyshake()*angles(math.rad(178.7+10*math.sin(sine/30)),math.rad(24.9),math.rad(-16.9+20*cs(30))),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,0.2+.4*math.sin(sine/30),-1.1)*angles(math.rad(-14.7+10*math.sin(sine/30)),math.rad(-5.6+10*cs(70)),math.rad(10*cs(80)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.2)*angles(math.rad(17.5+10*cs(60)),math.rad(14.4+10*cs(68)),math.rad(-7.8+10*cs(90)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "INTRICACY" then
				Anim = "idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(48),height,1*cs(57))*angles(math.rad(5*cs(25)),math.rad(64.5+5*cs(60)),math.rad(5*cs(39)))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0,0)*furyshake()*angles(math.rad(-9+4*math.sin(sine/33)),math.rad(-64.2+5*cs(80)),math.rad(-8.1+5*cs(71)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.6+.15*math.sin(sine/33),0.4)*furyshake()*angles(math.rad(10.6),math.rad(31.3),math.rad(-39.7)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.2,1.1+.15*math.sin(sine/33),-0.3)*furyshake()*angles(math.rad(157.5),math.rad(9.5),math.rad(29.8)),lerp)
				RH.C0=RH.C0:Lerp(cf(1.2,-0.2+.3*math.sin(sine/33),-0.6)*angles(math.rad(2.4-10*math.sin(sine/33)),math.rad(-29.7),math.rad(6.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.1)*angles(math.rad(5*cs(47)),math.rad(11.1+5*cs(53)),math.rad(-11.3+5*cs(30)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "SAGITTARIUS" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,14+2*cs(50))*angles(math.rad(-36.8),math.rad(42.4),math.rad(-41.9)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(60),math.rad(-9.8),math.rad(45.6)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.4,0.1)*furyshake()*angles(math.rad(-12.4),math.rad(-24.3),math.rad(23.4)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,-0.2,-0.5)*furyshake()*angles(math.rad(119.1),math.rad(7),math.rad(-7.7)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-1,-0.1)*angles(math.rad(-37.4),math.rad(28.4),math.rad(-18))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.4,-0.1,-1.2)*angles(math.rad(-36.2),math.rad(-26.5),math.rad(21.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "HARMONY" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,18+2*cs(50))*angles(math.rad(-25+5*cs(55)),math.rad(5*cs(58)),math.rad(5*cs(45))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(-22.7+5*cs(54)),math.rad(5*cs(48)),math.rad(5*cs(51))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,1,0)*furyshake()*angles(math.rad(-25.4),math.rad(0),math.rad(-90+10*math.sin(sine/-50))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,1,0)*furyshake()*angles(math.rad(-25.4),math.rad(0),math.rad(90-10*math.sin(sine/-50))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.8,0.1)*angles(math.rad(-25.6+5*cs(59)),math.rad(14.5+5*cs(57)),math.rad(-2.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.7,-0.4+.3*cs(55),-1)*angles(math.rad(-44.9+10*cs(58)),math.rad(-15.2+5*cs(47)),math.rad(13.7+5*cs(44)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
		end
		
		if anim.Value == "SWITCH START" then
			local lerp = .4
			if height == 0 then
				RootJoint.C0=RootJoint.C0:Lerp(cf(0,0.1,-0.3)*angles(math.rad(-35.5),math.rad(0),math.rad(0))*RootCF,.1)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-27.1),math.rad(math.random(-2,2)),math.rad(math.random(-2,2)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1,-0.5)*angles(math.rad(161.1+math.random(-2,2)),math.rad(-4.6+math.random(-2,2)),math.rad(-32.5+math.random(-2,2))),lerp)
				LS.C0=LS.C0:Lerp(cf(-0.9,0.3,-0.5)*angles(math.rad(166.3+math.random(-2,2)),math.rad(-6.3+math.random(-2,2)),math.rad(22.1+math.random(-2,2))),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1.1,-0.2)*angles(math.rad(36.3),math.rad(-16.7),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,-0.2)*angles(math.rad(33),math.rad(17.9),math.rad(-15.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
			else
				RootJoint.C0=RootJoint.C0:Lerp(cf(0,height,-0.3)*angles(math.rad(-35.5),math.rad(0),math.rad(0))*RootCF,.1)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-27.1),math.rad(math.random(-2,2)),math.rad(math.random(-2,2)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1,-0.5)*angles(math.rad(161.1+math.random(-2,2)),math.rad(-4.6+math.random(-2,2)),math.rad(-32.5+math.random(-2,2))),lerp)
				LS.C0=LS.C0:Lerp(cf(-0.9,0.3,-0.5)*angles(math.rad(166.3+math.random(-2,2)),math.rad(-6.3+math.random(-2,2)),math.rad(22.1+math.random(-2,2))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4,-1.1)*angles(math.rad(-54.9),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
		elseif anim.Value == "SWITCH" then
			local lerp = .1
			if height == 0 then
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,0)*angles(math.rad(-19.5),math.rad(0),math.rad(0)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-49.5),math.rad(0),math.rad(0)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.9,-0.1)*angles(math.rad(-22),math.rad(17.9),math.rad(-15.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0)*angles(math.rad(-18.7),math.rad(-16.7),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			else
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height)*angles(math.rad(-19.5),math.rad(0),math.rad(0)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-49.5),math.rad(0),math.rad(0)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4,-1.1)*angles(math.rad(-54.9),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
		elseif anim.Value == "SWING" then
			lerp = .4
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0.5)*angles(math.rad(5.4),math.rad(-25.2),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.1,0.2,0.2)*angles(math.rad(-18.7),math.rad(26.7),math.rad(8.4))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.6,0.7)*angles(math.rad(118.6),math.rad(7.6),math.rad(-2.5)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.6,-0.1)*angles(math.rad(6.1),math.rad(-9.9),math.rad(-16.5)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.8,0.2)*angles(math.rad(-12.1),math.rad(-22.7),math.rad(24.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.2)*angles(math.rad(-5.9),math.rad(36.9),math.rad(-2.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "GRAB" then
			lerp = .6
			RootJoint.C0=RootJoint.C0:Lerp(cf(-0.1,0,-0.1)*angles(math.rad(-8.7),math.rad(17.3),math.rad(-6.8))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.3,0.1,0)*angles(math.rad(4),math.rad(-15.2),math.rad(10.9))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0.7,-1.5)*angles(math.rad(104.8),math.rad(11.3),math.rad(-2.9)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,0.5,0)*angles(math.rad(25.5),math.rad(10.5),math.rad(-18.7)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.8,0.2)*angles(math.rad(-12.1),math.rad(-22.7),math.rad(24.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.9,-0.6)*angles(math.rad(6.6),math.rad(1.8),math.rad(-12.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "SLAM" then
			lerp = .9
			RootJoint.C0=RootJoint.C0:Lerp(cf(-0.1,-0.6,-0.6)*angles(math.rad(-40.7),math.rad(32.3),math.rad(-7.7))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.5)*angles(math.rad(-33.7),math.rad(-31.6),math.rad(-8.1))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.7,0.4,-1)*angles(math.rad(48),math.rad(-5.6),math.rad(31.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5,-0.1)*angles(math.rad(16.1),math.rad(-14.6),math.rad(-39)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.7,-0.1)*angles(math.rad(8.2),math.rad(-27.9),math.rad(32.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-0.7,-0.8)*angles(math.rad(41.1),math.rad(-16.8),math.rad(-1.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONBOMBCHARGE" then
			lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.2,0)*angles(math.rad(19.2),math.rad(0),math.rad(-30.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0.3,0,0.1)*angles(math.rad(10.4),math.rad(14),math.rad(24.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.1,0.5,-0.6)*angles(math.rad(-150.1),math.rad(-70.7),math.rad(121.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.8,0.9,0.6)*angles(math.rad(-142),math.rad(63.2),math.rad(-131.2)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.8,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.8,-1.2,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONBOMBDETONATE" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.2,0)*angles(math.rad(19.2),math.rad(0),math.rad(-30.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0.3,0,0.1)*angles(math.rad(10.4),math.rad(14),math.rad(24.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.1,0.5,-0.6)*angles(math.rad(-150.1),math.rad(-70.7),math.rad(121.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(0.7,0.5,-1)*angles(math.rad(-160.2),math.rad(47.4),math.rad(-116)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.8,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.8,-1.2,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONCIRCLESSTART" then
			lerp = .2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,-0.1)*angles(math.rad(11.9),math.rad(-.6),math.rad(42.4)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-18.2),math.rad(8.6),math.rad(-47.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4,0.5,0.3)*angles(math.rad(-27.3),math.rad(-33.6),math.rad(25.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(0.9,0,-0.8)*angles(math.rad(86.1),math.rad(-3.4),math.rad(-74.3)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1.1,0.2)*angles(math.rad(8.4),math.rad(8.7),math.rad(-10.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0.4)*angles(math.rad(3.9),math.rad(-39.7),math.rad(12.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONCIRCLESEND" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,-0.1)*angles(math.rad(26),math.rad(-11.4),math.rad(-29.6)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-21.6),math.rad(-6.6),math.rad(30.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4,0.5,0.3)*angles(math.rad(-27.3),math.rad(-33.6),math.rad(25.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,0.8,-0.7)*angles(math.rad(101.1),math.rad(24.7),math.rad(33.9)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(math.rad(-13.3),math.rad(30.5),math.rad(0.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-0.8,-0.2)*angles(math.rad(14.3),math.rad(10.6),math.rad(16.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "TELEPORT" then
			lerp = .08
			local addition = 0
			if height == 0 then addition = 2 end
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height+addition)*angles(math.rad(-2.7),math.rad(-16.9),math.rad(-32)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(27),math.rad(28.1),math.rad(25.4)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.4,0.4)*angles(math.rad(47.1),math.rad(-6.7),math.rad(-28.4)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.9,-0.3)*angles(math.rad(155.2),math.rad(48.8),math.rad(0.1)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1.1,-0.3)*angles(math.rad(-28.2),math.rad(20.3),math.rad(4.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,0.1,-1.2)*angles(math.rad(-33.4),math.rad(-15.1),math.rad(5.1))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "PowerFall" then
			lerp = .05
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.2,-0.2)*angles(math.rad(66.4),math.rad(0),math.rad(-47.3)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(21),math.rad(14.1),math.rad(42.8)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,-0.4,0.1)*angles(math.rad(126.3),math.rad(-58.8),math.rad(-40.9)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.9,1,0.3)*angles(math.rad(155.3),math.rad(56.7),math.rad(-84.8)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1.4,0.3)*angles(math.rad(-114.4),math.rad(-1.5),math.rad(34.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.6,-0.1,-1)*angles(math.rad(-19.6),math.rad(-3),math.rad(31.1))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "PowerHit" then
			lerp = .99
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.2,-0.2,-0.7)*angles(math.rad(44.4),math.rad(-32.2),math.rad(39.6)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(76.3),math.rad(-34.8),math.rad(-26.9)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,-0.4,0.1)*angles(math.rad(126.3),math.rad(-58.8),math.rad(-40.9)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.5,0.3,0.1)*angles(math.rad(-29.5),math.rad(44.4),math.rad(93.8)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.6,0)*angles(math.rad(-43.7),math.rad(32.4),math.rad(-26.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.7,0.2,-0.2)*angles(math.rad(32.7),math.rad(-30.6),math.rad(44.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionGrab" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-.1,0)*angles(math.rad(13),math.rad(4.5),math.rad(-26.3)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(6.6),math.rad(-8.1),math.rad(-41.7)),lerp)
			LS.C0=LS.C0:Lerp(cf(0.8,0.2,-1.4)*angles(math.rad(106.4),math.rad(-16.1),math.rad(97)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0,-0.1)*angles(math.rad(69.9),math.rad(2.4),math.rad(55.7)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.4,-0.1)*angles(math.rad(27.4),math.rad(38.6),math.rad(-18.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-1,0)*angles(math.rad(-7),math.rad(-13.3),math.rad(2))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionThrow" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0.2,.5,0)*angles(math.rad(12.1),math.rad(13.7),math.rad(15.7)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-37),math.rad(5.3),math.rad(-36.4)),lerp)
			LS.C0=LS.C0:Lerp(cf(-0.4,1.7,-1)*angles(math.rad(-165.7),math.rad(6.7),math.rad(-0.5)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,1.4,-0.4)*angles(math.rad(-179.2),math.rad(45.5),math.rad(25.5)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.2,-0.7)*angles(math.rad(1),math.rad(-12.9),math.rad(-23.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-28.9),math.rad(-23.9),math.rad(4))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionCharge" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0.3,-0.1)*angles(math.rad(-39.1),math.rad(0),math.rad(0)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-57.9),math.rad(0),math.rad(0)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,1.3,1.1)*angles(math.rad(-117.3),math.rad(26.6),math.rad(32.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1,1.3,1)*angles(math.rad(-109.5),math.rad(-17.8),math.rad(-24.4)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,-1.1)*angles(math.rad(-73.8),math.rad(13.9),math.rad(-11.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-0.9,0)*angles(math.rad(-30.2),math.rad(-9.9),math.rad(5.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionSlam" then
			lerp = .9
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,0.2)*angles(math.rad(20.5),math.rad(0),math.rad(0)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(15.4),math.rad(0),math.rad(0)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,0.9,-0.9)*angles(math.rad(84.5),math.rad(26.6),math.rad(32.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1,0.9,-0.8)*angles(math.rad(92.4),math.rad(-17.8),math.rad(-24.4)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,-1.1)*angles(math.rad(-73.8),math.rad(13.9),math.rad(-11.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-0.9,0)*angles(math.rad(-30.2),math.rad(-9.9),math.rad(5.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "RESTING" then
			lerp = .05
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.3,0.5,height-0.1+.2*cs(40))*angles(math.rad(-58.3+3*cs(70)),math.rad(39.1+8*cs(78)),math.rad(25.7+8*cs(67))),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,-.2,.3)*angles(math.rad(66.7),math.rad(-17.8+10*cs(80)),math.rad(9.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4-.1*cs(80),1.2,-0.1+.1*cs(80))*angles(math.rad(122.5),math.rad(0),math.rad(46.7-5*cs(80))),lerp)
			RS.C0=RS.C0:Lerp(cf(0.8,0.5,0.8+.3*math.sin(sine/40))*angles(math.rad(-80.3+5*cs(59)),math.rad(-4.3+5*cs(54)),math.rad(-40.4+5*cs(47))),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,-0.2)*angles(math.rad(-34.4+10*math.sin(sine/40)),math.rad(9.1),math.rad(-37.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-1.5,0)*angles(math.rad(-22.9+10*math.sin(sine/40)),math.rad(-11.1),math.rad(-54.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "FLAMETHROWERSTART" then
			lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.1,0.6,-0.7)*angles(math.rad(-25),math.rad(10.4),math.rad(-23.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(30.2),math.rad(-3.3),math.rad(21.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,1.2,-0.7)*angles(math.rad(169.7),math.rad(6.9),math.rad(16)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,1.2,-0.7)*angles(math.rad(178.6),math.rad(-8.7),math.rad(-13.9)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-0.8,-0.7)*angles(math.rad(-11.4),math.rad(26.7),math.rad(-13.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.7,-1.1,-0.6)*angles(math.rad(-58.6),math.rad(-16.9),math.rad(11))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "FLAMETHROWEREND" then
			lerp = .7
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.1,-0.7,-0.4)*angles(math.rad(11.1),math.rad(10.4),math.rad(-23.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-17.9),math.rad(-14.7),math.rad(13.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,1.1,-0.3)*angles(math.rad(90.1),math.rad(-1),math.rad(-8.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(0.7,0.8,-1.1)*angles(math.rad(91.8),math.rad(-18.8),math.rad(-38.5)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.6,0.2)*angles(math.rad(26.9),math.rad(19),math.rad(-27.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-1.4,0.1)*angles(math.rad(-29.4),math.rad(-11.4),math.rad(-3.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "HADOUKENSTART" then
			lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(cf(0.3,-0.3,-0.5)*angles(math.rad(-40.8),math.rad(-55.6),math.rad(-26.3))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.1,0,-0.1)*angles(math.rad(0),math.rad(64.8),math.rad(5.3))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.4,0.7,0.3)*angles(math.rad(53.8),math.rad(60),math.rad(47)),lerp)
			LS.C0=LS.C0:Lerp(cf(-0.7,0.2,-0.8)*angles(math.rad(88.9),math.rad(-3),math.rad(67.9)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1.3,0.1)*angles(math.rad(12.4),math.rad(-29.9),math.rad(16.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0.4)*angles(math.rad(19.6),math.rad(63.7),math.rad(-12.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "HADOUKENEND" then
			lerp = .8
			RootJoint.C0=RootJoint.C0:Lerp(cf(0.3,-0.3,-0.8)*angles(math.rad(-31.5),math.rad(-45),math.rad(-14.2))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0,-0.1)*angles(math.rad(5.5),math.rad(51),math.rad(-3.7))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(0,0.8,-1.3)*angles(math.rad(108),math.rad(-12.2),math.rad(-48.8)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4,0.6,-0.2)*angles(math.rad(109.7),math.rad(-7.8),math.rad(-45.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1.3,0.1)*angles(math.rad(12.4),math.rad(-29.9),math.rad(16.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0.4)*angles(math.rad(19.6),math.rad(63.7),math.rad(-12.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "VINDICTIVE Z" then
			local lerp = .05
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,5,0.3)*angles(math.rad(39.9),math.rad(0),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.6)*angles(math.rad(-36.9),math.rad(0),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0.5,-0.5)*angles(math.rad(93.8),math.rad(0),math.rad(-40.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,0.6,-0.6)*angles(math.rad(111.1),math.rad(0),math.rad(40.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.6,0.2,-0.9)*angles(math.rad(-3.6),math.rad(-14.8),math.rad(22.9))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0.1)*angles(math.rad(0),math.rad(21.6),math.rad(-15.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "VINDICTIVE Z END" then
			local lerp = .8
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,5,0.3)*angles(math.rad(59.4+math.random(-2,2)),math.rad(math.random(-2,2)),math.rad(math.random(-2,2)))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.4,-0.8)*angles(math.rad(54.5+math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5)))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.5,-0.1)*angles(math.rad(126.9+math.random(-5,5)),math.rad(2.5+math.random(-5,5)),math.rad(86.5+math.random(-5,5))),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.6,0)*angles(math.rad(116.1+math.random(-5,5)),math.rad(-5.2+math.random(-5,5)),math.rad(-90.5+math.random(-5,5))),lerp)
			RH.C0=RH.C0:Lerp(cf(0.6,0.2,-0.9)*angles(math.rad(-3.6+math.random(-5,5)),math.rad(-14.8+math.random(-5,5)),math.rad(22.9+math.random(-5,5)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0.1)*angles(math.rad(math.random(-5,5)),math.rad(21.6+math.random(-5,5)),math.rad(-15.3+math.random(-5,5)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Ground Stomp 1" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,1)*angles(math.rad(23.7),math.rad(29.2),math.rad(-4.7))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.2,0.4,0.8)*angles(math.rad(-44.1),math.rad(-20.2),math.rad(-12.3))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(22.7)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.7,0)*angles(math.rad(-9.5),math.rad(0),math.rad(-16.2)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.8,0.4,-0.8)*angles(math.rad(-2.7),math.rad(-17.1),math.rad(14.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.9,0.2)*angles(math.rad(-22.9),math.rad(22.4),math.rad(-6.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Ground Stomp 2" then
			local lerp = .99
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,-0.3,-0.2)*angles(math.rad(-11.2),math.rad(29.2),math.rad(-4.7))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-25.2),math.rad(-22.9),math.rad(-5.2))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(70.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.8,-0.1)*angles(math.rad(-9.5),math.rad(0),math.rad(-72.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.5,-0.5)*angles(math.rad(3.4),math.rad(-32.1),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.9,0.1)*angles(math.rad(-12.5),math.rad(21.2),math.rad(1.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Mouse1Start" then
			local lerp = .2
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,height,0)*angles(math.rad(0),math.rad(31.2),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0,0)*angles(math.rad(0),math.rad(-31.2),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.4,0.7,-0.8)*angles(math.rad(90.6),math.rad(0),math.rad(30.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.6,0)*angles(math.rad(-11),math.rad(-4.5),math.rad(-18.4)),lerp)
			if height == 0 then
				RH.C0=RH.C0:Lerp(cf(1,-1,0)*angles(math.rad(2.7),math.rad(-22.9),math.rad(6.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			else
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,0)*angles(math.rad(-3),math.rad(11.6),math.rad(-4.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Mouse1End" then
			local lerp = .7
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,height,-0.2)*angles(math.rad(-12.5),math.rad(31.2),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0,0)*angles(math.rad(10),math.rad(-31.2),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.4,0.4,-0.6)*angles(math.rad(-179.6),math.rad(3.8),math.rad(-6.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.5,0)*angles(math.rad(-11),math.rad(-4.5),math.rad(-64.2)),lerp)
			if height == 0 then
				RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0.1)*angles(math.rad(16.1),math.rad(-21.9),math.rad(13.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			else
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
			LH.C0=LH.C0:Lerp(cf(-0.9,-1.1,0)*angles(math.rad(6.4),math.rad(11.7),math.rad(2.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Healing Burst Start" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,-0.2)*angles(math.rad(-5.5),math.rad(0),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-27.8),math.rad(0),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0,-0.5)*angles(math.rad(103),math.rad(14.7),math.rad(-63)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.2,0,-0.3)*angles(math.rad(89.3),math.rad(-7.2),math.rad(49.5)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1,0.1)*angles(math.rad(6.1),math.rad(-10.9),math.rad(4.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.1)*angles(math.rad(5.2),math.rad(7.5),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Healing Burst End" then
			local lerp = .7
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0.2)*angles(math.rad(11.8),math.rad(0),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0,-0.3)*angles(math.rad(15.2),math.rad(0),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.9,-0.2)*angles(math.rad(95.4),math.rad(16.2),math.rad(80.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.8,0.8,-0.3)*angles(math.rad(89.6),math.rad(-15.4),math.rad(-65.4)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0)*angles(math.rad(-11.1),math.rad(-10.9),math.rad(4.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-0.9,0)*angles(math.rad(-12),math.rad(7.5),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Execution Z 1" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(80),5-1*math.cos(sine/50),1*cs(70))*angles(math.rad(75.1),math.rad(55.3),math.rad(-52.3))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.2,0.2,0.6)*angles(math.rad(-11.3),math.rad(-64.8),math.rad(29.1))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.5,-0.1)*angles(math.rad(-28),math.rad(25.7),math.rad(162.7)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,-0.3,-0.2)*angles(math.rad(113.9),math.rad(25.4),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,0,-0.7)*angles(math.rad(-19),math.rad(-16.2),math.rad(7.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-46.8),math.rad(9.3),math.rad(-10.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Execution Z 2" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(80),5-1*math.cos(sine/50),1*cs(70))*angles(math.rad(75.1),math.rad(55.3),math.rad(-52.3))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.2,0.2,0.6)*angles(math.rad(-11.3),math.rad(-64.8),math.rad(29.1))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,-0.4,0.5)*angles(math.rad(-28),math.rad(25.7),math.rad(162.7)),.99)
			LS.C0=LS.C0:Lerp(cf(-1.5,-0.3,-0.2)*angles(math.rad(113.9),math.rad(25.4),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,0,-0.7)*angles(math.rad(-19),math.rad(-16.2),math.rad(7.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-46.8),math.rad(9.3),math.rad(-10.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "ApexRun" then
			local lerp = .3
			local m = 6
			local n = m/2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/n)+.05*math.sin(sine/n))*angles(math.rad(10+20+3*math.cos(sine/n)),0,math.rad(4*math.cos(sine/m))),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(-20-7*math.cos(sine / n)),0,math.rad(-3*math.cos(sine/m))),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,0.1,0.3)*angles(math.rad(0),math.rad(-54.3),math.rad(50.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-0.8,0.8,-1)*angles(math.rad(105.9),math.rad(-13.6),math.rad(81.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-.8+.5*math.sin(sine/-m),0-.25*math.cos(sine/m)-0.2)*angles(0,math.rad(90),0)*angles(0,math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m))),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-.8+.5*math.sin(sine/m),0+.25*math.cos(sine/m)-0.2)*angles(0,math.rad(-90),0)*angles(0,math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m))),lerp)
		elseif anim.Value == "Coin Toss 1" then
			local lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,height-1,-0.1)*angles(math.rad(30.4),math.rad(-12.2),math.rad(7.1))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0.3,0.6)*angles(math.rad(-38.4),math.rad(-26.3),math.rad(-3.9))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,0.2,0.1)*angles(math.rad(58.5),math.rad(-3.6),math.rad(-24.9)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,0.2,-0.5)*angles(math.rad(63.9),math.rad(-18.1),math.rad(67.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.7,-1.3)*angles(math.rad(-55.1),math.rad(-21.2),math.rad(9.4))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.7,-0.8,-0.2)*angles(math.rad(-43.3),math.rad(13.6),math.rad(-14.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Coin Toss 2" then
			local lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(cf(0.1,height,-0.2)*angles(math.rad(32.9),math.rad(24.4),math.rad(-14.9))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.2,0,0)*angles(math.rad(-8),math.rad(-24.9),math.rad(10.3))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0,-0.4)*angles(math.rad(109.6),math.rad(7),math.rad(10.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,0.2,-0.5)*angles(math.rad(63.9),math.rad(-18.1),math.rad(67.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.7,-1.3)*angles(math.rad(-55.1),math.rad(-21.2),math.rad(9.4))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.7,-0.8,-0.2)*angles(math.rad(-43.3),math.rad(13.6),math.rad(-14.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		end
	end
end
